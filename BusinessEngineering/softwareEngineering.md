# Software Engineering | A Learning Guide

This is a Complete Software Engineering Summary Notes Guide i put together with basic [Software Engineering](https://piusnmuhumuza.hashnode.dev/a-business-technology-enthusiasts-guide-to-software-engineering) definitions, concepts, and practices for busy business technologists & thought leaders.

## Introduction

Back in the 1950s, when the dependency on computers increased, the software needed to manage them also grew and thus [Software Engineering/Development](https://piusnmuhumuza.hashnode.dev/a-business-technology-enthusiasts-guide-to-software-engineering) became a necessity for businesses and users all over the world.

> [â€œOur civilization depends critically on software, and we have a dangerously low degree of professionalism in the computer fields.â€ â€” Bjarne Stroustrup]( https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/resources/BjarneStroustrup.pdf)

In the last 63 years (since 1960), the amount of software produced and used by modern society increased greatly necessitating a need to set principles, objectives, and standards, when estimating the necessary resources (like cost and human capital) for developing quality software to meet customer requirements and manage their expectations.

Today, it is hard to imagine an area of human activity or business endeavour where software is not used, considering most of the devices used in workplaces, households and the large computer infrastructures operating in governmental organizations or large corporations are powered by software.

This publication tries to break down most of the software-related concepts, practices, and topics that anyone in the business of [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) as well as enthusiasts should know about.

## What is Software

Software is a set of _computer programs_ that enable a computer system (_hardware_) to perform specific tasks. Software runs on **hardware** which are the tangible components, or delivery systems that store and run the written instructions provided by the software to perform the actual work.

High-quality software was and is characterized with being highly dependable, safe, secure, reliability, efficient, usable, accessible, and maintainable. It is not feasible to achieve all these in any one software product but achieving some is possible.

### Characteristics of Software

* Software is developed or engineered and not manufactured.
* Software doesnâ€™t wear out but it does require enhancements or scaling depending on how, where, and for whom itâ€™s being developed.
* Software should be applicable, maintainable, scalable, reliable, efficient, and well documented at the very least to be considered quality when handing it over to the client.
* Software and especially good software is operational, transitional, and maintainable.
* Software can also have some restrictions e.g., legal compliances, industry standards, Cost, talent hiring, and time to market among others that need to be considered.

## What is Software Engineering

Software Engineering is a technical discipline or approach that applies **computer science** and **engineering** concepts in the design, development, testing and maintenance of quality reliable, usable, and dependable software.

The professional practice of Software Engineering requires technical proficiency and a high code of ethics, which all enthusiasts of Software Engineering should embody. The [10 commandments of Egoless programming]( https://medium.com/@piusnmuhumuza/reflecting-on-the-10-commandments-of-egoless-programming-1bc4189e32f) by inspired by the book, [The Psychology of Computer Programming]( https://www.goodreads.com/book/show/1660754.The_Psychology_of_Computer_Programming) , first released in the 1970s, where Jerry Weinberg coined the term â€œegoless programmingâ€ partly speaks to this effect.

> [â€œWhen a Princeton neighbour of Albert Einsteinâ€™s discovered to her horror that her little girl had been going to Einstein for help with her arithmetic homework, she apologized profusely. Think nothing of it, Einstein replied â€” I have learned more from her than she has from me.â€](https://x.com/JerryWeinberg/status/1022591845430452224?s=20) -Tweet by [Gerald Weinberg](https://x.com/JerryWeinberg)

## A brief History of Software Engineering

The term **â€˜Software Engineeringâ€™** first was used in the late 1950s and early 1960s, where â€˜The Concept of Software Engineering was first discussed at the 1968 NATO Science Committee in (Garmisch) Germany.

The NATO Science Committee sponsored two conferences ([The NATO Software Engineering Conferences]( http://homepages.cs.ncl.ac.uk/brian.randell/NATO/)) on _Software Engineering_ in 1968 and 1969, which as generally believed, marked the official start of the profession giving the field its initial boost as the term _'Software Engineering'_ was suggested at these conferences to discuss the ['software crisis'](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/theSoftwareCrisis.md), a name given to the difficulties encountered in developing large, complex systems in the 1960s (through the 1970s -80s).

Around this period, a lot of software projects ran over budget and schedule, some causing property damage while a few led to the loss of life.

## The Software Crisis (1960)

[Software Crisis](https://en.wikipedia.org/wiki/Software_crisis) was a term that came to be used in the early days of computing science referring to the difficulty of developing large, complex systems in the 1960s (through the 1970s -80s) as well as writing useful and efficient computer programs (Software) by Software Engineers and Developers within the required time due to the rapid increase in computer power. During this period, the increasing complexity of the software, and inadequacy of the existing methods, lead to many software problems arising which caused many large-scale software development projects to fail.

This ended up costing more money and taking more time to develop Software than was estimated, with the final product often being inefficient and low quality, if, and when, finished at all.

As computers became larger and more powerful, the task of creating equally large and powerful software (computer programs) also became gigantic, and the field struggled to keep up, leading to the situation referred to today as [_â€œThe Software Crisisâ€_](https://en.wikipedia.org/wiki/Software_crisis)

In his 1972 [Turing Award](https://en.wikipedia.org/wiki/Turing_Award) lecture, [Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra) made a reference to this same problem.

> â€œBut I called this a minor cause; the major cause is... that the machines have become several orders of magnitude more powerful! To put it quite bluntly: as long as there were no machines, programming was no problem at all; when we had a few weak computers, programming became a mild problem, and now we have gigantic computers, programming had become an equally gigantic problem.â€ â€“-**[Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra), [The Humble Programmers (1972)](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/theHumbleProgrammer.md)**

The term ["Software Crisis"]( https://en.wikipedia.org/wiki/Software_crisis) was coined together by attendees at the first [NATO Software Engineering Conference](https://en.wikipedia.org/wiki/NATO_Software_Engineering_Conferences) in 1968 at Garmisch, Germany.

## The Beginning of Software Engineering

In the wake of the [Software crisis](https://en.wikipedia.org/wiki/Software_crisis), [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) emerged as a new engineering discipline concerned with all aspects pertaining to software production that encompassed the theories, concepts, principles, techniques, standards, and tools that could be used for developing high-quality and reliable professional software.

By identifying the many problems of software development It was thus, proposed that the adoption of an engineering approach to developing software which is how [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) was conceptualized.

The term [â€˜Software Engineeringâ€™](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) first was used in the late 1950s and early 1960s, where the concept of software engineering was first suggested at the 1968 NATO Science Committee in (Garmisch) Germany, while discussing the '[Software Crisis](https://en.wikipedia.org/wiki/Software_crisis)'. It is generally believed these conferences marked the official start of the profession as the term ['Software Engineering'](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76).
The NATO Science Committee sponsored two conferences ( [The NATO Software Engineering Conferences]( http://homepages.cs.ncl.ac.uk/brian.randell/NATO/)  ) on [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) in 1968 and 1969, which gave the field its initial boost.

## Breaking Down Software Engineering

[Software Engineering](https://piusnmuhumuza.hashnode.dev/a-business-technology-enthusiasts-guide-to-software-engineering) is a body of knowledge whose concepts and principles can be approached in parallel with the software development life cycle beginning with a general introduction to software engineering, which essentially defines this body of knowledge, as well as the main methodologies of software engineering.

It emphasizes a systematic, disciplined approach to the development of software that typically applies to the construction of large software systems (or products) involving numerous Software Development and engineering teams.

Today, Software Development and engineering teams will typically fall under Front-end, Back-end or full-stack development, as is with Developers, Engineers and sometimes Programmers.

### Front-end Vs Back-end Vs Full-stack Development

Front-ends work on what the user can see while Back-ends build the infrastructure that supports it and Full-stacks are both in one. Both Front-ends & Back-ends are necessary components for high-functioning software or applications.

* **Front-end â€”** ensures a satisfactory user experience with no issues, errors, or downtime by planning, designing, building, and implementing quality user interface systems for the software or application in question. Front-ends create and optimize systems, resolve UI/UX issues and even play an active role in testing and troubleshooting activities.

* **Back-end â€”** typically deals with the logical back-end and core computational logic. Back-ends are responsible for the server-side/back-end part of a software or application and usually write the business logic of software, web services, and APIs used by front-end.

* **Full-stack â€”** usually comes with experience of working both as a Front-end and Back-end. Often referred to as â€œjack-of-all-tradesâ€, Full-stacks have skills in a wide variety of coding niches, databases, graphic design, and UI/UX that enables them do their job well working both the client and server ends.

### The case of a Software Engineer Vs a Software Developer

While _Developers_ and _Engineers_ apply advanced technical skills to create computer programs, and their roles overlap in many ways depending on the team one is working on, _Software Developers_ and _Software Engineers_ typically handle different steps when creating applications.

**Software Developers** identify customer needs, develop, and customize computer software applications, test, and modify the software as needed to meet those needs, for many industries while **Software Engineers** are considered a type of _Software Developer_, who apply engineering principles, knowledge of programming languages, architecture, and structural design to build systems and software solutions for end users and are typically involved in all stages of the Software development life cycle.

The _Software Developer vs. Software Engineer_ issue often puzzles many technology professionals and aspiring software professionals may confuse the two positions, because the two professional roles share similar responsibilities and sometimes educational backgrounds with titles often being used interchangeably, but they generally differ in their methods and outcomes.

_Software Developers_ and _Software Engineers_ typically handle different steps when creating applications with **Software Developers**, often working directly with clients or as part of a team of developers, engineers, and programmers to create software solutions that meet specific user needs and **Software Engineers** typically working in teams with other developers, project managers, product managers and other professionals considering all components of a project and how potential solutions may affect the project overall.

Also, **Software Engineers** tend to be in more collaborative roles, while **Software Developers** often and may work in a more independent environment.

### Developer expertise Levels

They are basically 3 levels but, in some places, or companies, you will find 5 or 7 levels depending on the breakdown and classifications of the expertise levels.

As you grow your experience in the Software Engineering industry you will go through several levels based on your expertise.

The 3 common basic levels are;-

* **Junior Developer:**

While starting out, most _Developers_ will be Trainees/Apprentices or referred to as Junior Developer most as commonly known in the software industry. At this level, you probably have 0 to 1.5 years of experience tops and everything you know about Software Engineering is basic at best.

You will work on a team where you either pair, work with or have your code reviewed by another Developer probably a mid-level developer before it gets to the Senior developer or Lead Developer.

Read my Article; â€” [The Struggles of a Junior Software Developer](https://piusnmuhumuza.medium.com/the-struggles-of-a-junior-software-developer-20856d57150e) to get a feel of the experience a typical Junior Developer goes through.

* **Mid-Level Developer:**

Mostly referred to as _Intermediate Developer_ on some Job descriptions (JDs) put out by hiring companies or recruiter, _a mid-level Developer_ is any developer with 2â€“3 years under their belt and has developed a substantial level of technical skills in the software engineering industry.

At this level, a developer has worked on some projects and can work unsupervised on a team among other things or under limited supervision which is typically code/tasks review from the Senior Developer who will act as a guide, mentor, and advisor for the most part.

* **Senior Developer:**

This developer is also known as the **Developer Lead** or **Team Lead** and is often referred to as a problem solver, because of their deep, specialized knowledge and exhaustive experience in the software engineering industry, knowledge of programming languages, tech stack, or even a specific product they are working or worked on.

At this level, a Developer has somewhere 5 to 8 years+ of experience and able to handle complex problems, comfortably review other developersâ€™ codes, solve their problems, be a trendsetter when working on projects, and most importantly mentor Junior & Mid-level Developers.


### Key Activities in Software Engineering when managing Software Projects

Good software is characterised by functional and non-functional requirements among other client needs often specified from which an analysis/planning is made to ascertain a scope. It will also undergo a life-cycle(software process), that involves engineering phases, consisting of concept creation, requirements specification, design, implementation, integration, testing, and deployment.

The Software Development Life Cycle (SDLC) is the process for planning, creating, testing, deploying and post improvement (where required) of a software product. â€” It consists of stages (Analysis/ Planning, Design, Development/Implementation, Testing, Deployment, and then maintenance.) which are sometimes unchangeable at certain levels depending on the industry, client requirements and team. 

As software evolves, it will undergo monitoring, maintenance and continuous improvement cycles and each software development lifecycle model provides specific guidance to the sequencing and repetition of life cycle activities to deliver high-quality software systems.

Project management in a software engineering environment is unique because of the technical aspects of a software project. While software engineers are generally accountable for the technical aspects of a project, the project manager is accountable for organizational aspects. Sometimes a project manager can be the Software Developer on a project.

The success of an SDLC depends on the people, process, and product and software project management is the glue that holds these aspects together.

#### Software Requirements Gathering and Analysis

During requirements gathering/elicitation, Software Engineer/Developer or Business Analysts interact and collaborate with the various stakeholders, including customers and users, to gather information, assemble the insight, identify, translate, analyze and validate the project's needs about the current state of a software system and desired future state of the software system to be developed. 
Getting familiar with the data, information types, requirements collection techniques, application types, client engineering techniques can go a long way to help your business case. 

### Software Design and Modelling

After requirements and analysis, a Software Engineer/Developer must transform the analysis model into a design model that can be implemented in a specific hardware and software environment.

Good Software design is fundamental to creating successful software which starts with gathering requirements followed by precisely articulating complex ideas using industry-standard design visual language tools such as Unified Modeling Language (UML) which enables you specify, construct, and document the artifacts of the software systems among other activities.

### Software Implementation

Implementation, is the process of converting the specified requirements into an actual software product. This can be programming, coding source code and execution. Software implementation also involves customer engineering to ensure software is working as expected of the client/end user during implementation and deployment.

In most business settings, steps like implementing, testing (User acceptance testing) and deployment can happen concurrently or inter-changeably depending on client requirements or team.

### Software Testing

Software testing is a process of using various industry-standard techniques to show and verify that a software, meets requirements, industry standards and is fit for use.

During software testing, you validate the software requirements analysis, software design, during software implementation to make sure everything comes together correctly to deliver a software system that performs as expected, functionally and non-functionally.

At a granual level, the purpose of software testing is to identify errors, gaps, or missing requirements and check whether the said software product is defect-free and matches the expected client requirements.

Sometimes testing can happen early in the development lifecycle depending on the team workflow, methodology or client requirements but it mostly ensures that the quality of the overall software from varying levels of granularity is as per expectations before sign off or software project handover.

#### Some types of software testing include; -

* **Functional Testing** (_Unit testing, Integration testing, System testing, Interface testing, Regression testing, Beta/acceptance testing_)
* **Non-Functional Testing** (_Performance testing, Load testing, Stress testing, Volume testing, Security testing, Compatibility testing, Install testing, Recovery testing, Reliability testing, Usability testing, Compliance testing_).

### Software Project Handover

Software Project handover is the transfer of roles and responsibilities for a software project from one company, team, or person to another.

It is a complex process that includes user acceptance testing, deployment, acceptance criteria, post hand-over maintenance, project to mention but a few depending on the client or the team handling the software project.

Even though project handover is an important part of the software product lifecycle, it can be costly or take unpredictable turns unless appropriate precautionary steps are taken.

Typically, all stakeholders of the software project are present if possible for the hand over where final sign off take place and the Software product is handed of signaling the end of the project and making way for any post-project activities like support, maintenance and continuous improvement

### Conclusion

Software Engineering/Development outside in the business environment is a very complex process, mostly because real-world software is much larger, more complex and run on big budgets with a lot of uncertainties, timelines and often unreasonable expectations from the various stakeholders.

> ["Programming isn't about what you know; it's about what you can figure out." â€“ Chris Pine.]( https://x.com/CodeWisdom/status/1728034677531763017?s=20)

It is a lucrative venture and getting proficient or mastering the various software engineering concepts, principles, essential processes and industry standards can give you an edge in the cut-throat competitive technology space.

There are several areas to focus on within **Software Engineering**, such as _Programming Basics, Software design, Software Processes, Software Project management, Software testing, Software Quality Assurance(SQA), Configuration Management, Database Design and Administration, Human-Computer Interaction, UI/UX Concepts, Operating Systems, Computer and Software Architecture, Software Modelling and Analysis, Embedded Systems, ML/AI & GenAI, Computer Networking and Security concepts, Research and Development(R&D)/Research Methodology,  Data Structures and Algorithms(DSA), Technical Writing and Social Responsibility/Legal & Ethics among other disciplines._

These can be different or categorized differently depending on the information source, learning center or mode of research on your part.

### Glossary

* **Computer programs** are a set of instructions/algorithms applied to various types of data that is used as a process of creating the software program with the help of a programming language.
* **Development:** Is the process of developing, being developed, or the result of developing.
* **Engineering:** Mostly involves applying science, conventional methods, and applicable tools to find cost-effective and sustainable/scalable solutions to developing problems. This can be in any industry where engineering is applicable.
* **Software** is a set of _computer programs_ that enable a computer system (_hardware_) to perform specific tasks.
* **Software Architecture:** Refers to the fundamental structures or building blocks of a software system. The way software components (subroutines, classes, functions) are arranged and interact or integrate with each other.
* **Software Engineering:** Is a systematic, disciplined & more so quantifiable approach to the development, operation, and maintenance of software or software projects.

* **Software Development:** Is a set of activities _conceiving, specifying, designing, programming, deploying, documenting, and testing (bug fixing)_ involved in the process of creating and maintaining software applications, frameworks, or other software components.
* **[Software Development Life Cycle (SDLC);](https://en.wikipedia.org/wiki/Systems_development_life_cycle)** is the process of developing or engineering software. â€” â€œthe overall process of developing software from start to finish.â€

### Reading Resources

* [Software engineering history](https://ifs.host.cs.st-andrews.ac.uk/Books/SE9/Web/History/#:~:text=The%20term%20'software%20engineering'%20was,complex%20systems%20in%20the%201960s.)
* [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76)
* [History of software engineering]( https://en.wikipedia.org/wiki/History_of_software_engineering)
* [The History of Software Engineering]( https://www.lingq.com/en/learn-english-online/courses/10892/the-history-of-software-engineering-10892/)
* [9 Steps to Software Project Handovers]( https://betterprogramming.pub/9-steps-to-software-project-handovers-9325fbb72cfc)
* [ğ—¦ğ—¼ğ—³ğ˜ğ˜„ğ—®ğ—¿ğ—² ğ—˜ğ—»ğ—´ğ—¶ğ—»ğ—²ğ—²ğ—¿ğ—¶ğ—»ğ—´ ğ—®ğ˜ ğ—šğ—¼ğ—¼ğ—´ğ—¹ğ—²](https://abseil.io/resources/swe-book/html/toc.html)
* [The Humble Programmer | Edsger W. Dijkstra | ACM Turing Lecture 1972](https://www.youtube.com/watch?v=0dGXRK8FUVg&ab_channel=RenTristandelaCruz)
* [Has the Software Crisis Passed?]( https://medium.com/@ryancohane/has-the-software-crisis-passed-d45ce975a1e7)
* [The Humble Programmer; Recorded by Eric Normand. Published: August 2, 2021. Updated: August 17, 2021.]( https://lispcast.com/the-humble-programmer/)
* [Software Engineering](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/resources/The%20NATO%20Software%20Engineering%20Conferences/software-engineering_nato1968.pdf)
* [Software Engineering Techniques](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/resources/The%20NATO%20Software%20Engineering%20Conferences/Software-Engineering-techniques_nato1969.pdf)
* [The Software of Civilization](https://foresight.org/the-software-of-civilization/)
* [A Basic understanding of Software Quality Assurance.](https://medium.com/@piusnmuhumuza/a-basic-understanding-of-software-quality-assurance-307317b82867)
* [Software Quality Assurance: Beyond the Basics.](https://piusnmuhumuza.medium.com/software-quality-assurance-beyond-the-basics-f159780bc55f)
* [Being a good Software Quality Assurance Engineer](https://piusnmuhumuza.medium.com/being-a-good-software-quality-assurance-engineer-9e229eba89d6)
* [Software Engineering: A Business Tech Enthusiast Beginnerâ€™s Guide](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76)
* [Test Types and Maintenance Testing](https://testingtraveler.com/2021/02/05/test-types-and-maintenance-testing/)
* [The 4 Levels of Testing in Software Engineering Explained](https://fellow.app/blog/engineering/the-levels-of-testing-in-software-engineering-explained/)
* [The different types of software testing](https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing)

### Tags

``Software``, ``Software Crisis``, ``The Humble Programmer``, ``Computer Science``, ``Software Engineering``, ``Software Quality``, ``Software Developer``, ``Software Engineer``, ``Software Development``, ``Software Crisis``, ``Software Quality Assurance``, ``Software Testing``,``Software Development Life Cycle``, ``SDLC``, ``NATO Science Committee``, ``The NATO Software Engineering Conferences``