# Software Engineering | A Learning Guide

This is a Complete Software Engineering Summary Notes Guide i put together with basic [Software Engineering](https://piusnmuhumuza.hashnode.dev/a-business-technology-enthusiasts-guide-to-software-engineering) definitions, concepts, and practices for busy business technologists & thought leaders.

## Introduction

Back in the 1950s, when the dependency on computers increased, the software needed to manage them also grew and thus [Software Engineering/Development](https://piusnmuhumuza.hashnode.dev/a-business-technology-enthusiasts-guide-to-software-engineering) became a necessity for businesses and users all over the world.

> [“Our civilization depends critically on software, and we have a dangerously low degree of professionalism in the computer fields.” — Bjarne Stroustrup]( https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/resources/BjarneStroustrup.pdf)

In the last 63 years (since 1960), the amount of software produced and used by modern society increased greatly necessitating a need to set principles, objectives, and standards, when estimating the necessary resources (like cost and human capital) for developing quality software to meet customer requirements and manage their expectations.

Today, it is hard to imagine an area of human activity or business endeavour where software is not used, considering most of the devices used in workplaces, households and the large computer infrastructures operating in governmental organizations or large corporations are powered by software.

This publication tries to break down most of the software-related concepts, practices, and topics that anyone in the business of [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) as well as enthusiasts should know about.

## What is Software

Software is a set of _computer programs_ that enable a computer system (_hardware_) to perform specific tasks. Software runs on **hardware** which are the tangible components, or delivery systems that store and run the written instructions provided by the software to perform the actual work.

High-quality software was and is characterized with being highly dependable, safe, secure, reliability, efficient, usable, accessible, and maintainable. It is not feasible to achieve all these in any one software product but achieving some is possible.

### Characteristics of Software

* Software is developed or engineered and not manufactured.
* Software doesn’t wear out but it does require enhancements or scaling depending on how, where, and for whom it’s being developed.
* Software should be applicable, maintainable, scalable, reliable, efficient, and well documented at the very least to be considered quality when handing it over to the client.
* Software and especially good software is operational, transitional, and maintainable.
* Software can also have some restrictions e.g., legal compliances, industry standards, Cost, talent hiring, and time to market among others that need to be considered.

## What is Software Engineering

Software Engineering is a technical discipline or approach that applies **computer science** and **engineering** concepts in the design, development, testing and maintenance of quality reliable, usable, and dependable software.

The professional practice of Software Engineering requires technical proficiency and a high code of ethics, which all enthusiasts of Software Engineering should embody. The [10 commandments of Egoless programming]( https://medium.com/@piusnmuhumuza/reflecting-on-the-10-commandments-of-egoless-programming-1bc4189e32f) by inspired by the book, [The Psychology of Computer Programming]( https://www.goodreads.com/book/show/1660754.The_Psychology_of_Computer_Programming) , first released in the 1970s, where Jerry Weinberg coined the term “egoless programming” partly speaks to this effect.

> [“When a Princeton neighbour of Albert Einstein’s discovered to her horror that her little girl had been going to Einstein for help with her arithmetic homework, she apologized profusely. Think nothing of it, Einstein replied — I have learned more from her than she has from me.”](https://x.com/JerryWeinberg/status/1022591845430452224?s=20) -Tweet by [Gerald Weinberg](https://x.com/JerryWeinberg)

## A brief History of Software Engineering

The term **‘Software Engineering’** first was used in the late 1950s and early 1960s, where ‘The Concept of Software Engineering was first discussed at the 1968 NATO Science Committee in (Garmisch) Germany.

The NATO Science Committee sponsored two conferences ([The NATO Software Engineering Conferences]( http://homepages.cs.ncl.ac.uk/brian.randell/NATO/)) on _Software Engineering_ in 1968 and 1969, which as generally believed, marked the official start of the profession giving the field its initial boost as the term _'Software Engineering'_ was suggested at these conferences to discuss the ['software crisis'](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/theSoftwareCrisis.md), a name given to the difficulties encountered in developing large, complex systems in the 1960s (through the 1970s -80s).

Around this period, a lot of software projects ran over budget and schedule, some causing property damage while a few led to the loss of life.

## The Software Crisis (1960)

[Software Crisis](https://en.wikipedia.org/wiki/Software_crisis) was a term that came to be used in the early days of computing science referring to the difficulty of developing large, complex systems in the 1960s (through the 1970s -80s) as well as writing useful and efficient computer programs (Software) by Software Engineers and Developers within the required time due to the rapid increase in computer power. During this period, the increasing complexity of the software, and inadequacy of the existing methods, lead to many software problems arising which caused many large-scale software development projects to fail.

This ended up costing more money and taking more time to develop Software than was estimated, with the final product often being inefficient and low quality, if, and when, finished at all.

As computers became larger and more powerful, the task of creating equally large and powerful software (computer programs) also became gigantic, and the field struggled to keep up, leading to the situation referred to today as [_“The Software Crisis”_](https://en.wikipedia.org/wiki/Software_crisis)

In his 1972 [Turing Award](https://en.wikipedia.org/wiki/Turing_Award) lecture, [Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra) made a reference to this same problem.

> “But I called this a minor cause; the major cause is... that the machines have become several orders of magnitude more powerful! To put it quite bluntly: as long as there were no machines, programming was no problem at all; when we had a few weak computers, programming became a mild problem, and now we have gigantic computers, programming had become an equally gigantic problem.” –-**[Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra), [The Humble Programmers (1972)](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/theHumbleProgrammer.md)**

The term ["Software Crisis"]( https://en.wikipedia.org/wiki/Software_crisis) was coined together by attendees at the first [NATO Software Engineering Conference](https://en.wikipedia.org/wiki/NATO_Software_Engineering_Conferences) in 1968 at Garmisch, Germany.

## The Beginning of Software Engineering

In the wake of the [Software crisis](https://en.wikipedia.org/wiki/Software_crisis), [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) emerged as a new engineering discipline concerned with all aspects pertaining to software production that encompassed the theories, concepts, principles, techniques, standards, and tools that could be used for developing high-quality and reliable professional software.

By identifying the many problems of software development It was thus, proposed that the adoption of an engineering approach to developing software which is how [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) was conceptualized.

The term [‘Software Engineering’](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) first was used in the late 1950s and early 1960s, where the concept of software engineering was first suggested at the 1968 NATO Science Committee in (Garmisch) Germany, while discussing the '[Software Crisis](https://en.wikipedia.org/wiki/Software_crisis)'. It is generally believed these conferences marked the official start of the profession as the term ['Software Engineering'](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76).
The NATO Science Committee sponsored two conferences ( [The NATO Software Engineering Conferences]( http://homepages.cs.ncl.ac.uk/brian.randell/NATO/)  ) on [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) in 1968 and 1969, which gave the field its initial boost.

## Breaking Down Software Engineering

[Software Engineering](https://piusnmuhumuza.hashnode.dev/a-business-technology-enthusiasts-guide-to-software-engineering) is a body of knowledge whose concepts and principles can be approached in parallel with the software development life cycle beginning with a general introduction to software engineering, which essentially defines this body of knowledge, as well as the main methodologies of software engineering.

It emphasizes a systematic, disciplined approach to the development of software that typically applies to the construction of large software systems (or products) involving numerous Software Development and engineering teams.

Today, Software Development and engineering teams will typically fall under Front-end, Back-end or full-stack development, as is with Developers, Engineers and sometimes Programmers.

### Front-end Vs Back-end Vs Full-stack Development

Front-ends work on what the user can see while Back-ends build the infrastructure that supports it and Full-stacks are both in one. Both Front-ends & Back-ends are necessary components for high-functioning software or applications.

* **Front-end —** ensures a satisfactory user experience with no issues, errors, or downtime by planning, designing, building, and implementing quality user interface systems for the software or application in question. Front-ends create and optimize systems, resolve UI/UX issues and even play an active role in testing and troubleshooting activities.

* **Back-end —** typically deals with the logical back-end and core computational logic. Back-ends are responsible for the server-side/back-end part of a software or application and usually write the business logic of software, web services, and APIs used by front-end.

* **Full-stack —** usually comes with experience of working both as a Front-end and Back-end. Often referred to as “jack-of-all-trades”, Full-stacks have skills in a wide variety of coding niches, databases, graphic design, and UI/UX that enables them do their job well working both the client and server ends.

### The case of a Software Engineer Vs a Software Developer

While _Developers_ and _Engineers_ apply advanced technical skills to create computer programs, and their roles overlap in many ways depending on the team one is working on, _Software Developers_ and _Software Engineers_ typically handle different steps when creating applications.

**Software Developers** identify customer needs, develop, and customize computer software applications, test, and modify the software as needed to meet those needs, for many industries while **Software Engineers** are considered a type of _Software Developer_, who apply engineering principles, knowledge of programming languages, architecture, and structural design to build systems and software solutions for end users and are typically involved in all stages of the Software development life cycle.

The _Software Developer vs. Software Engineer_ issue often puzzles many technology professionals and aspiring software professionals may confuse the two positions, because the two professional roles share similar responsibilities and sometimes educational backgrounds with titles often being used interchangeably, but they generally differ in their methods and outcomes.

_Software Developers_ and _Software Engineers_ typically handle different steps when creating applications with **Software Developers**, often working directly with clients or as part of a team of developers, engineers, and programmers to create software solutions that meet specific user needs and **Software Engineers** typically working in teams with other developers, project managers, product managers and other professionals considering all components of a project and how potential solutions may affect the project overall.

Also, **Software Engineers** tend to be in more collaborative roles, while **Software Developers** often and may work in a more independent environment.

### Developer expertise Levels

They are basically 3 levels but, in some places, or companies, you will find 5 or 7 levels depending on the breakdown and classifications of the expertise levels.

As you grow your experience in the Software Engineering industry you will go through several levels based on your expertise.

The 3 common basic levels are;-

* **Junior Developer:**

While starting out, most _Developers_ will be Trainees/Apprentices or referred to as Junior Developer most as commonly known in the software industry. At this level, you probably have 0 to 1.5 years of experience tops and everything you know about Software Engineering is basic at best.

You will work on a team where you either pair, work with or have your code reviewed by another Developer probably a mid-level developer before it gets to the Senior developer or Lead Developer.

Read my Article; — [The Struggles of a Junior Software Developer](https://piusnmuhumuza.medium.com/the-struggles-of-a-junior-software-developer-20856d57150e) to get a feel of the experience a typical Junior Developer goes through.

* **Mid-Level Developer:**

Mostly referred to as _Intermediate Developer_ on some Job descriptions (JDs) put out by hiring companies or recruiter, _a mid-level Developer_ is any developer with 2–3 years under their belt and has developed a substantial level of technical skills in the software engineering industry.

At this level, a developer has worked on some projects and can work unsupervised on a team among other things or under limited supervision which is typically code/tasks review from the Senior Developer who will act as a guide, mentor, and advisor for the most part.

* **Senior Developer:**

This developer is also known as the **Developer Lead** or **Team Lead** and is often referred to as a problem solver, because of their deep, specialized knowledge and exhaustive experience in the software engineering industry, knowledge of programming languages, tech stack, or even a specific product they are working or worked on.

At this level, a Developer has somewhere 5 to 8 years+ of experience and able to handle complex problems, comfortably review other developers’ codes, solve their problems, be a trendsetter when working on projects, and most importantly mentor Junior & Mid-level Developers.

## Software Project Management

The Business Of Project Management is about understanding the management of project information, resourcing, costing and budgeting to deliver on-time, on-budget and in-scope project. Project management of software products can be loosely referred to as Software Project management.

### Key Activities in Software Engineering when managing Software Projects

Good software is characterized by functional and non-functional requirements among other client needs often specified from which an analysis/planning is made to ascertain a scope. It will also undergo a life-cycle(software process), that involves engineering phases, consisting of concept creation, requirements specification, design, implementation, integration, testing, and deployment.

The Software Development Life Cycle (SDLC) is the process for planning, creating, testing, deploying and post improvement (where required) of a software product. — It consists of stages (Analysis/ Planning, Design, Development/Implementation, Testing, Deployment, and then maintenance.) which are sometimes unchangeable at certain levels depending on the industry, client requirements and team. 

As software evolves, it will undergo monitoring, maintenance and continuous improvement cycles and each software development lifecycle model provides specific guidance to the sequencing and repetition of life cycle activities to deliver high-quality software systems.

Project management in a software engineering environment is unique because of the technical aspects of a software project. While software engineers are generally accountable for the technical aspects of a project, the project manager is accountable for organizational aspects. Sometimes a project manager can be the Software Developer on a project.

The success of an SDLC depends on the people, process, and product and software project management is the glue that holds these aspects together.

#### Software Requirements Gathering and Analysis

During requirements gathering/elicitation, Software Engineer/Developer or Business Analysts interact and collaborate with the various stakeholders, including customers and users, to gather information, assemble the insight, identify, translate, analyze and validate the project's needs about the current state of a software system and desired future state of the software system to be developed. 
Getting familiar with the data, information types, requirements collection techniques, application types, client engineering techniques can go a long way to help your business case. 

### Software Design and Modelling

After requirements and analysis, a Software Engineer/Developer must transform the analysis model into a design model that can be implemented in a specific hardware and software environment.

Good Software design is fundamental to creating successful software which starts with gathering requirements followed by precisely articulating complex ideas using industry-standard design visual language tools such as Unified Modeling Language (UML) which enables you specify, construct, and document the artifacts of the software systems among other activities.

### Software Implementation

Implementation, is the process of converting the specified requirements into an actual software product. This can be programming, coding source code and execution. Software implementation also involves customer engineering to ensure software is working as expected of the client/end user during implementation and deployment.

In most business settings, steps like implementing, testing (User acceptance testing) and deployment can happen concurrently or inter-changeably depending on client requirements or team.

## Software Testing

In the software business, a software product is tested thoroughly like before being shipped to the client. During Software Testing, you validate if the finished product meets set software, requirements, industry standards and passes user acceptance to make sure everything comes together correctly to deliver a software system that performs as expected, functionally and non-functionally.
At a granular level, the purpose of software testing is to identify errors, gaps, or missing requirements and check whether the said software product is defect-free and matches the expected client requirements.

### What is Software Testing

Software Testing is a process of using various industry-standard techniques to evaluating, show and verify that a software product being developed does what it is supposed to do, meets clients requirements and is fit for use. It’s is part of Software Quality Assurance.

It checks whether the actual software product matches expected requirements and ensures that the software product is defect/bug-free prior to release/launch.
Sometimes testing can happen early in the development lifecycle depending on the team workflow, methodology or client requirements but it mostly ensures that the quality of the overall software from varying levels of granularity is as per expectations before sign off or software project handover.

There are different levels of testing, from functional to acceptance, and each one checks specific things to make sure everything is up to standard.

While Software Quality Assurance and Software Testing are used interchangeably in the Software Engineering/Development space, and both aim to provide software that meets the necessary requirements and quality standards, they are not exactly the same. In fact, they are quite different.

Software testing concentrates on finding the bugs, defects, and errors within the software, while Software Quality Assurance aims to assure that the overall quality of the software product being engineered/developed meets the requirements and expectations of the client.

**Note:** Software testing is a part of the general quality control process within Software Quality Assurance, but its focus is exclusively on product-oriented tasks rather than the big picture.

### Who does software testing?

* Software Tester
* Software Developer/Engineer.
* Software Quality Assurance Engineers can also test.
* Project Lead/Manager
* End User/Client.

### The Seven testing principles are; —

The seven basic software testing principles that every software tester and QA professional should know represent the ground rules for optimizing the testing process to get the best quality on your software testing investment.

1. **Testing shows presence of defects**
Reporting zero bugs/defects after a testing cycle does not mean the software is bug-free but rather the test cases probably did not cover all scenarios. The goal of testing is to make the software fail by showing the presence of bugs/defects in the software and sufficient testing reduces the presence of defects.

2. **Exhaustive testing is impossible**
Trying to exhaust all possible test conditions of a software, by going through every test case is impractical as it burns time and money without affecting the overall quality. So instead of trying to do exhaustive testing, it’s more effective to estimate testing efforts and consider risks and priorities in order to optimize the number of test cases for better testing.

3. **Early testing**
With the help of unit testing and Integration testing in the early phases of the SDLC, defects can be detected early on thus saving time, avoiding massive delays and reducing the cost of fixing those defects than if detected later during system testing.

4. **Defect clustering**
This principle simply states that a small number of modules or functionalities (20%) can contain most of the software defects/bugs or operational failures (80%) or 80% of software defect comes from 20% of modules. Based on the popular Pareto Principle.

5. **Pesticide paradox**
This principle says that trying to repeat the same test cases, repeatedly, will not find new bugs eventually making the software being tested immune to the tests. It is necessary to rethink your test approach, review the test cases regularly and add or update them to find more bugs/defects.

6. **Testing is context-dependent**
There is no one-strategy-fits-all in software testing rather testing approach depends on the context of the software we develop. We do test the software differently in different contexts. Different types of software need to perform different types of testing.

7. **Absence of errors-fallacy**
It is a common belief in the software engineering space that a low defect rate implies the software product is okay and the software project is a success which is an absence-of-errors delusion. Zero defects do not mean the software solves end-user problems successfully. In fact, even bug-free software can fail to address the business needs of a client if wrong inputs were incorporated into the software.

### Why is Software Testing Needed?

Software testing plays a crucial role in delivering reliable and high-quality software as well as mitigating risks, enhances user satisfaction, and ensuring a smooth user experience. It's essential to have robust testing processes to succeed in order to;-

* Identifying Bugs and Defects
* Ensuring Quality
* Meeting Requirements
* Enhancing Reliability
* Preventing Future Issues and many more.

### Breakdown Software Testing

As an Engineer, Developer, Product Manager or Project Manager, it’s important to know the levels of software testing and why going through each level is so crucial for software Quality Assurance and a software project’s success.
There are so many ways of approaching software testing based on the project type, the Software product the client expectations, the budget or the Engineering Team available during the software Life cycle.
I will document the simple approach I followed to avoid getting confused and I believe it can be built on by anyone reading this documentation.

#### Software Testing Typically falls under 3 categories; -

* Functional Testing: A type of software testing that validates the software against a list of requirements or specifications. These tests aim to assess each application function and mainly involve black box testing. Functional testing analyses details like user interface, database, security, application programming interfaces (APIs), and client/server communication. Functional Testing will usually have _Unit testing, Integration testing, System testing, Interface testing, Regression testing, Beta/acceptance testing_

* Non-Functional Testing: Sometimes called performance testing, this method focuses on testing an application for its non-functional elements and requirements. Non-functional elements encompass things like performance, reliability, and usability. An example of a test would be checking how many users can be logged into a tool simultaneously without the tool lagging or glitching. Test carried out here often include _Performance testing, Load testing, Stress testing, Volume testing, Security testing, Compatibility testing, Install testing, Recovery testing, Reliability testing, Usability testing, Compliance testing_.

* Maintenance Testing: A method of software testing that aims to uncover software errors or bugs within a program after changes have been made. It retests the program to ensure that after the changes are complete, the changes don’t negatively impact the features within the code or conflict with necessary requirements. Test carried out in Maintenance Testing include Regression testing, confirmation testing.

### Levels of Testing

The different levels of software testing explore the four software testing levels that take place during the development lifecycle with each level conducted thoroughly, checking for something different—nothing should be rushed or skipped.
These are; —

#### Unit Testing

This is usually done at the code level, testing individual parts or components (units) of a software to analyse their functionality and ensure each piece of the software functions correctly on its own and works as intended.

#### Integration Testing

Is the process of testing how different units or components work together when integrated into a larger system to check if the combined units cooperate as expected and don't cause issues when connected. It enables software testers to test units of software when integrated into a whole system to identify any bugs or issues arising from integrations between modules. It is possible to automate integration testing.

#### System Testing

This is the process of testing the entire system (an integrated environment comprising the whole application), where all components are assessed against specific business requirements to verify that it meets the specified requirements, and ensure the complete software system functions correctly and satisfies user needs. Automation tools can be used for System Testing.

#### Acceptance Testing

This is where a team checks if the software meets the requirements and specifications set by the end-users or clients to confirm that the software is ready for release and satisfies the user's expectations and needs. Acceptance testing involves testing the system’s Functional and Non-functional aspects, such as performance, security, usability, accessibility, compatibility, and reliability. Depending on the system’s complexity, it can be done manually or through automation tools.

### Software Project Handover

Software Project handover is the transfer of roles and responsibilities for a software project from one company, team, or person to another.

It is a complex process that includes user acceptance testing, deployment, acceptance criteria, post hand-over maintenance, project to mention but a few depending on the client or the team handling the software project.

Even though project handover is an important part of the software product lifecycle, it can be costly or take unpredictable turns unless appropriate precautionary steps are taken.

Typically, all stakeholders of the software project are present if possible for the hand over where final sign off take place and the Software product is handed of signaling the end of the project and making way for any post-project activities like support, maintenance and continuous improvement

## Conclusion

Software Engineering/Development outside in the business environment is a very complex process, mostly because real-world software is much larger, more complex and run on big budgets with a lot of uncertainties, timelines and often unreasonable expectations from the various stakeholders.

> ["Programming isn't about what you know; it's about what you can figure out." – Chris Pine.]( https://x.com/CodeWisdom/status/1728034677531763017?s=20)

It is a lucrative venture and getting proficient or mastering the various software engineering concepts, principles, essential processes and industry standards can give you an edge in the cut-throat competitive technology space.

There are several areas to focus on within **Software Engineering**, such as _Programming Basics, Software design, Software Processes, Software Project management, Software testing, Software Quality Assurance(SQA), Configuration Management, Database Design and Administration, Human-Computer Interaction, UI/UX Concepts, Operating Systems, Computer and Software Architecture, Software Modelling and Analysis, Embedded Systems, ML/AI & GenAI, Computer Networking and Security concepts, Research and Development(R&D)/Research Methodology,  Data Structures and Algorithms(DSA), Technical Writing and Social Responsibility/Legal & Ethics among other disciplines._

These can be different or categorized differently depending on the information source, learning center or mode of research on your part.

## Glossary

* **Computer programs** are a set of instructions/algorithms applied to various types of data that is used as a process of creating the software program with the help of a programming language.
* **Development:** Is the process of developing, being developed, or the result of developing.
* **Engineering:** Mostly involves applying science, conventional methods, and applicable tools to find cost-effective and sustainable/scalable solutions to developing problems. This can be in any industry where engineering is applicable.
* **Project management** is the process of planning and executing a project while balancing the time, cost, and scope constraints. Time, cost, and scope are known as the _triple constraint_.
* **Software** is a set of _computer programs_ that enable a computer system (_hardware_) to perform specific tasks.
* **Software Architecture:** Refers to the fundamental structures or building blocks of a software system. The way software components (subroutines, classes, functions) are arranged and interact or integrate with each other.
* **Software Engineering:** Is a systematic, disciplined & more so quantifiable approach to the development, operation, and maintenance of software or software projects.

* **Software Development:** Is a set of activities _conceiving, specifying, designing, programming, deploying, documenting, and testing (bug fixing)_ involved in the process of creating and maintaining software applications, frameworks, or other software components.
* **[Software Development Life Cycle (SDLC);](https://en.wikipedia.org/wiki/Systems_development_life_cycle)** is the process of developing or engineering software. — “the overall process of developing software from start to finish.”

## Reading Resources

* [Software engineering history](https://ifs.host.cs.st-andrews.ac.uk/Books/SE9/Web/History/#:~:text=The%20term%20'software%20engineering'%20was,complex%20systems%20in%20the%201960s.)
* [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76)
* [History of software engineering]( https://en.wikipedia.org/wiki/History_of_software_engineering)
* [The History of Software Engineering]( https://www.lingq.com/en/learn-english-online/courses/10892/the-history-of-software-engineering-10892/)
* [9 Steps to Software Project Handovers]( https://betterprogramming.pub/9-steps-to-software-project-handovers-9325fbb72cfc)
* [𝗦𝗼𝗳𝘁𝘄𝗮𝗿𝗲 𝗘𝗻𝗴𝗶𝗻𝗲𝗲𝗿𝗶𝗻𝗴 𝗮𝘁 𝗚𝗼𝗼𝗴𝗹𝗲](https://abseil.io/resources/swe-book/html/toc.html)
* [The Humble Programmer | Edsger W. Dijkstra | ACM Turing Lecture 1972](https://www.youtube.com/watch?v=0dGXRK8FUVg&ab_channel=RenTristandelaCruz)
* [Has the Software Crisis Passed?]( https://medium.com/@ryancohane/has-the-software-crisis-passed-d45ce975a1e7)
* [The Humble Programmer; Recorded by Eric Normand. Published: August 2, 2021. Updated: August 17, 2021.]( https://lispcast.com/the-humble-programmer/)
* [Software Engineering](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/resources/The%20NATO%20Software%20Engineering%20Conferences/software-engineering_nato1968.pdf)
* [Software Engineering Techniques](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/resources/The%20NATO%20Software%20Engineering%20Conferences/Software-Engineering-techniques_nato1969.pdf)
* [The Software of Civilization](https://foresight.org/the-software-of-civilization/)
* [A Basic understanding of Software Quality Assurance.](https://medium.com/@piusnmuhumuza/a-basic-understanding-of-software-quality-assurance-307317b82867)
* [Software Quality Assurance: Beyond the Basics.](https://piusnmuhumuza.medium.com/software-quality-assurance-beyond-the-basics-f159780bc55f)
* [Being a good Software Quality Assurance Engineer](https://piusnmuhumuza.medium.com/being-a-good-software-quality-assurance-engineer-9e229eba89d6)
* [Software Engineering: A Business Tech Enthusiast Beginner’s Guide](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76)
* [Test Types and Maintenance Testing](https://testingtraveler.com/2021/02/05/test-types-and-maintenance-testing/)
* [The 4 Levels of Testing in Software Engineering Explained](https://fellow.app/blog/engineering/the-levels-of-testing-in-software-engineering-explained/)
* [The different types of software testing](https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing)
* [Software Engineering Body of Knowledge (SWEBOK)](https://www.computer.org/education/bodies-of-knowledge/software-engineering)
* [ISO (International Organization for Standardization)](https://www.techtarget.com/searchdatacenter/definition/ISO)
* [A Guide to Understanding ISO Standards](https://www.jamasoftware.com/blog/a-guide-to-understanding-iso-standards/)
* [Project Management: An Agile Approach to Projects.](https://piusnmuhumuza.medium.com/project-management-an-agile-approach-to-projects-27e11098ce10)
* [Book Review: Scrum by Jeff Sutherland.](https://piusnmuhumuza.medium.com/book-review-scrum-by-jeff-sutherland-55221a14c232)
* [Agile 101](https://www.agilealliance.org/agile101/)
* [Manifesto for Agile Software Development](https://agilemanifesto.org/)
* [Principles behind the Agile Manifesto](https://agilemanifesto.org/principles.html)
* [The Role of Business Analysis in Project Management]( https://www.linkedin.com/pulse/role-business-analysis-project-management-mark-bruins/)
* [The Importance of a Business Analyst in Project Management](https://www.linkedin.com/pulse/importance-business-analyst-project-management-firdaus-jahan-xiwdf/)
* [Project Managers: How to Leverage Business Analysis for Project Success](https://www.adaptiveus.com/blog/business-analysis-for-project-managers/)
* [Why project managers need business analysis](https://harrybakertraining.com/project-management/why-project-managers-need-business-analysis/#:~:text=Business%20analysis%20competency%20helps%20project,the%20delivery%20of%20business%20value.)
* [Building Secure and Reliable Systems](https://google.github.io/building-secure-and-reliable-systems/raw/toc.html)
* [Google Site Reliability Engineering(SRE) Books](https://sre.google/books/)
* [Google SRE Book Github](https://github.com/euclid1990/google-sre-book)
* [Google SRE Book Read Online](https://landing.google.com/sre/sre-book/toc/index.html)
* [system-design-primer](https://github.com/donnemartin/system-design-primer.git)


### Tags

``Software``, ``Software Crisis``, ``The Humble Programmer``, ``Computer Science``, ``Software Engineering``, ``Software Quality``, ``Software Developer``, ``Software Engineer``, ``Software Development``, ``Software Crisis``, ``Software Quality Assurance``, ``Software Testing``,``Software Development Life Cycle``, ``SDLC``, ``NATO Science Committee``, ``The NATO Software Engineering Conferences``, ``SWEBOK``,``Software Project Management``