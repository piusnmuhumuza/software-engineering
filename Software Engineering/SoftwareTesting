# Software Testing

## Introduction

Software testing is the process of evaluating and verifying that a computer program or system functions as intended. 
It involves executing a program or system to identify any errors or gaps between the expected and actual outcomes. 
The goal is to ensure the software meets specified requirements, is free of defects, and works reliably in different scenarios.

Software testing is a process of using various industry-standard techniques to show and verify that a software, meets requirements, industry standards and is fit for use.

During software testing, you validate the software requirements analysis, software design, during software implementation to make sure everything comes together correctly to deliver a software system that performs as expected, functionally and non-functionally.

At a granual level, the purpose of software testing is to identify errors, gaps, or missing requirements and check whether the said software product is defect-free and matches the expected client requirements.

Sometimes testing can happen early in the development lifecycle depending on the team workflow, methodology or client requirements but it mostly ensures that the quality of the overall software from varying levels of granularity is as per expectations before sign off or software project handover.

## What is Software Testing

Software testing is the process of evaluating and verifying that a software product being developed does what it is supposed to do. It checks whether the actual software product matches expected requirements and ensures that the software product is defect/bug-free prior to release/launch.

## Is Software Quality Assurance and Software Testing the same?

While Software Quality Assurance and Software Testing are used interchangeably in the Software Engineering/Development space, and both aim to provide software that meets the necessary requirements and quality standards, they aren’t exactly the same. In fact, they’re actually quite different.
Software testing concentrates on finding the bugs, defects, and errors within the software, while software quality assurance aims to assure that the overall quality of the software product being engineered/developed meets the requirements and expectations of the client.

**Note:** Software testing is a part of the general quality control process within Software Quality Assurance, but its focus is exclusively on product-oriented tasks rather than the big picture.

## Why is Software Testing Needed?

Software testing plays a crucial role in delivering reliable and high-quality software as well as mitigating risks, enhances user satisfaction, and ensuring a smooth user experience.

It's essential to have robust testing processes to succeed in order to;-

* Identifying Bugs and Defects
* Ensuring Quality
* Meeting Requirements
* Enhancing Reliability
* Preventing Future Issues and many more.

## Who does software testing?!

•	Software Tester
•	Software Developer/Engineer.
•	Software Quality Assurance Engineers can also test.
•	Project Lead/Manager
•	End User/Client.

## The Seven testing principles are; —

The seven basic software testing principles that every software tester and QA professional should know represent the ground rules for optimizing the testing process to get the best quality on your software testing investment.

1. **Testing shows presence of defects**
Reporting zero bugs/defects after a testing cycle does not mean the software is bug-free but rather the test cases probably did not cover all scenarios. The goal of testing is to make the software fail by showing the presence of bugs/defects in the software and sufficient testing reduces the presence of defects.

2. **Exhaustive testing is impossible**
Trying to exhaust all possible test conditions of a software, by going through every test case is impractical as it burns time and money without affecting the overall quality. So instead of trying to do exhaustive testing, it’s more effective to estimate testing efforts and consider risks and priorities in order to optimize the number of test cases for better testing.

3. **Early testing**
With the help of unit testing and Integration testing in the early phases of the SDLC, defects can be detected early on thus saving time, avoiding massive delays and reducing the cost of fixing those defects than if detected later during system testing.

4. **Defect clustering**
This principle simply states that a small number of modules or functionalities (20%) can contain most of the software defects/bugs or operational failures (80%) or 80% of software defect comes from 20% of modules. Based on the popular Pareto Principle.

5. **Pesticide paradox**
This principle says that trying to repeat the same test cases, repeatedly, will not find new bugs eventually making the software being tested immune to the tests. It is necessary to rethink your test approach, review the test cases regularly and add or update them to find more bugs/defects.

6. **Testing is context-dependent**
There is no one-strategy-fits-all in software testing rather testing approach depends on the context of the software we develop. We do test the software differently in different contexts. Different types of software need to perform different types of testing.

7. **Absence of errors-fallacy**
It is a common belief in the software engineering space that a low defect rate implies the software product is okay and the software project is a success which is an absence-of-errors delusion. Zero defects do not mean the software solves end-user problems successfully. In fact, even bug-free software can fail to address the business needs of a client if wrong inputs were incorporated into the software.

## Some types of software testing include; -

* **Functional Testing** (_Unit testing, Integration testing, System testing, Interface testing, Regression testing, Beta/acceptance testing_)
* **Non-Functional Testing** (_Performance testing, Load testing, Stress testing, Volume testing, Security testing, Compatibility testing, Install testing, Recovery testing, Reliability testing, Usability testing, Compliance testing_).

## - Levels of Testing

### Unit Testing:

Testing individual parts or components (units) of a software to ensure they work as intended.
Why? To make sure each piece of the software functions correctly on its own.

### Integration Testing:

Testing how different units or components work together when integrated into a larger system.
Why? To check if the combined units cooperate as expected and don't cause issues when connected.

### System Testing:

Testing the entire system as a whole to verify that it meets the specified requirements.
Why? To ensure that the complete software system functions correctly and satisfies user needs.

### Acceptance Testing:

Checking if the software meets the requirements and specifications set by the end-users or clients.
Why? To confirm that the software is ready for release and satisfies the user's expectations and needs.