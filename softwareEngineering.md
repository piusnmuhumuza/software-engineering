# Software Engineering | A Learning Guide

This is a Complete Software Engineering Summary Notes Guide i put together with basic [Software Engineering](https://piusnmuhumuza.hashnode.dev/a-business-technology-enthusiasts-guide-to-software-engineering) definitions, concepts, and practices for busy business technologists & thought leaders.

## Table Of Contents

- [Introduction](#introduction)
- [What is Software](#what-is-software)
   -[Characteristics of Software](#characteristics-of-software)
- [What is Software Engineering](#what-is-software-engineering)

## Introduction

Back in the 1950s, when the dependency on computers increased, the software needed to manage them also grew and thus [Software Engineering/Development](https://piusnmuhumuza.hashnode.dev/a-business-technology-enthusiasts-guide-to-software-engineering) became a necessity for businesses and users all over the world.

> [“Our civilization depends critically on software, and we have a dangerously low degree of professionalism in the computer fields.” — Bjarne Stroustrup]( https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/resources/BjarneStroustrup.pdf)

In the last 63 years (since 1960), the amount of software produced and used by modern society increased greatly necessitating a need to set principles, objectives, and standards, when estimating the necessary resources (like cost and human capital) for developing quality software to meet customer requirements and manage their expectations.

Today, it is hard to imagine an area of human activity or business endeavour where software is not used, considering most of the devices used in workplaces, households and the large computer infrastructures operating in governmental organizations or large corporations are powered by software.

This publication tries to break down most of the software-related concepts, practices, and topics that anyone in the business of [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) as well as enthusiasts should know about.

## What is Software

Software is a set of _computer programs_ that enable a computer system (_hardware_) to perform specific tasks. Software runs on **hardware** which are the tangible components, or delivery systems that store and run the written instructions provided by the software to perform the actual work.

High-quality software was and is characterized with being highly dependable, safe, secure, reliability, efficient, usable, accessible, and maintainable. It is not feasible to achieve all these in any one software product but achieving some is possible.

### Characteristics of Software

- Software is developed or engineered and not manufactured.
- Software doesn’t wear out but it does require enhancements or scaling depending on how, where, and for whom it’s being developed.
- Software should be applicable, maintainable, scalable, reliable, efficient, and well documented at the very least to be considered quality when handing it over to the client.
- Software and especially good software is operational, transitional, and maintainable.
- Software can also have some restrictions e.g., legal compliances, industry standards, Cost, talent hiring, and time to market among others that need to be considered.

## What is Software Engineering

Software Engineering is a technical discipline or approach that applies **computer science** and **engineering** concepts in the design, development, testing and maintenance of quality reliable, usable, and dependable software.

The professional practice of Software Engineering requires technical proficiency and a high code of ethics, which all enthusiasts of Software Engineering should embody. The [10 commandments of Egoless programming]( https://medium.com/@piusnmuhumuza/reflecting-on-the-10-commandments-of-egoless-programming-1bc4189e32f) by inspired by the book, [The Psychology of Computer Programming]( https://www.goodreads.com/book/show/1660754.The_Psychology_of_Computer_Programming) , first released in the 1970s, where Jerry Weinberg coined the term “egoless programming” partly speaks to this effect.

> [“When a Princeton neighbour of Albert Einstein’s discovered to her horror that her little girl had been going to Einstein for help with her arithmetic homework, she apologized profusely. Think nothing of it, Einstein replied — I have learned more from her than she has from me.”](https://x.com/JerryWeinberg/status/1022591845430452224?s=20) -Tweet by [Gerald Weinberg](https://x.com/JerryWeinberg)

### A brief History of Software Engineering

The term **‘Software Engineering’** first was used in the late 1950s and early 1960s, where ‘The Concept of Software Engineering was first discussed at the 1968 NATO Science Committee in (Garmisch) Germany.

The NATO Science Committee sponsored two conferences ([The NATO Software Engineering Conferences]( http://homepages.cs.ncl.ac.uk/brian.randell/NATO/)) on _Software Engineering_ in 1968 and 1969, which as generally believed, marked the official start of the profession giving the field its initial boost as the term _'Software Engineering'_ was suggested at these conferences to discuss the ['software crisis'](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/theSoftwareCrisis.md), a name given to the difficulties encountered in developing large, complex systems in the 1960s (through the 1970s -80s).

Around this period, a lot of software projects ran over budget and schedule, some causing property damage while a few led to the loss of life.

### The Software Crisis (1960)

[Software Crisis](https://en.wikipedia.org/wiki/Software_crisis) was a term that came to be used in the early days of computing science referring to the difficulty of developing large, complex systems in the 1960s (through the 1970s -80s) as well as writing useful and efficient computer programs (Software) by Software Engineers and Developers within the required time due to the rapid increase in computer power. During this period, the increasing complexity of the software, and inadequacy of the existing methods, lead to many software problems arising which caused many large-scale software development projects to fail.

This ended up costing more money and taking more time to develop Software than was estimated, with the final product often being inefficient and low quality, if, and when, finished at all.

As computers became larger and more powerful, the task of creating equally large and powerful software (computer programs) also became gigantic, and the field struggled to keep up, leading to the situation referred to today as [_“The Software Crisis”_](https://en.wikipedia.org/wiki/Software_crisis)

In his 1972 [Turing Award](https://en.wikipedia.org/wiki/Turing_Award) lecture, [Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra) made a reference to this same problem.

> “But I called this a minor cause; the major cause is... that the machines have become several orders of magnitude more powerful! To put it quite bluntly: as long as there were no machines, programming was no problem at all; when we had a few weak computers, programming became a mild problem, and now we have gigantic computers, programming had become an equally gigantic problem.” –-**[Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra), [The Humble Programmers (1972)](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/theHumbleProgrammer.md)**

The term ["Software Crisis"]( https://en.wikipedia.org/wiki/Software_crisis) was coined together by attendees at the first [NATO Software Engineering Conference](https://en.wikipedia.org/wiki/NATO_Software_Engineering_Conferences) in 1968 at Garmisch, Germany.

### The Beginning of Software Engineering

In the wake of the [Software crisis](https://en.wikipedia.org/wiki/Software_crisis), [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) emerged as a new engineering discipline concerned with all aspects pertaining to software production that encompassed the theories, concepts, principles, techniques, standards, and tools that could be used for developing high-quality and reliable professional software.

By identifying the many problems of software development It was thus, proposed that the adoption of an engineering approach to developing software which is how [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) was conceptualized.

The term [‘Software Engineering’](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) first was used in the late 1950s and early 1960s, where the concept of software engineering was first suggested at the 1968 NATO Science Committee in (Garmisch) Germany, while discussing the '[Software Crisis](https://en.wikipedia.org/wiki/Software_crisis)'. It is generally believed these conferences marked the official start of the profession as the term ['Software Engineering'](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76).
The NATO Science Committee sponsored two conferences ( [The NATO Software Engineering Conferences]( http://homepages.cs.ncl.ac.uk/brian.randell/NATO/)  ) on [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) in 1968 and 1969, which gave the field its initial boost.

## Breaking Down Software Engineering

It emphasizes a systematic, disciplined approach to the development of software that typically applies to the construction of large software systems (or products) involving numerous Software Development and engineering teams.

Today, Software Development and engineering teams will typically fall under Front-end, Back-end or full-stack development, as is with Developers, Engineers and sometimes Programmers.

### Front-end Vs Back-end Vs Full-stack Development

Front-ends work on what the user can see while Back-ends build the infrastructure that supports it and Full-stacks are both in one. Both Front-ends & Back-ends are necessary components for high-functioning software or applications.

* **Front-end —** ensures a satisfactory user experience with no issues, errors, or downtime by planning, designing, building, and implementing quality user interface systems for the software or application in question. Front-ends create and optimize systems, resolve UI/UX issues and even play an active role in testing and troubleshooting activities.

* **Back-end —** typically deals with the logical back-end and core computational logic. Back-ends are responsible for the server-side/back-end part of a software or application and usually write the business logic of software, web services, and APIs used by front-end.

* **Full-stack —** usually comes with experience of working both as a Front-end and Back-end. Often referred to as “jack-of-all-trades”, Full-stacks have skills in a wide variety of coding niches, databases, graphic design, and UI/UX that enables them do their job well working both the client and server ends.

### The case of a Software Engineer Vs a Software Developer

While _Developers_ and _Engineers_ apply advanced technical skills to create computer programs, and their roles overlap in many ways depending on the team one is working on, _Software Developers_ and _Software Engineers_ typically handle different steps when creating applications.

**Software Developers** identify customer needs, develop, and customize computer software applications, test, and modify the software as needed to meet those needs, for many industries while **Software Engineers** are considered a type of _Software Developer_, who apply engineering principles, knowledge of programming languages, architecture, and structural design to build systems and software solutions for end users and are typically involved in all stages of the Software development life cycle.

The _Software Developer vs. Software Engineer_ issue often puzzles many technology professionals and aspiring software professionals may confuse the two positions, because the two professional roles share similar responsibilities and sometimes educational backgrounds with titles often being used interchangeably, but they generally differ in their methods and outcomes.

_Software Developers_ and _Software Engineers_ typically handle different steps when creating applications with **Software Developers**, often working directly with clients or as part of a team of developers, engineers, and programmers to create software solutions that meet specific user needs and **Software Engineers** typically working in teams with other developers, project managers, product managers and other professionals considering all components of a project and how potential solutions may affect the project overall.

Also, **Software Engineers** tend to be in more collaborative roles, while **Software Developers** often and may work in a more independent environment.

### Developer expertise Levels

They are basically 3 levels but, in some places, or companies, you will find 5 or 7 levels depending on the breakdown and classifications of the expertise levels.

As you grow your experience in the Software Engineering industry you will go through several levels based on your expertise.

The 3 common basic levels are;-

* **Junior Developer:**

While starting out, most _Developers_ will be Trainees/Apprentices or referred to as Junior Developer most as commonly known in the software industry. At this level, you probably have 0 to 1.5 years of experience tops and everything you know about Software Engineering is basic at best.

You will work on a team where you either pair, work with or have your code reviewed by another Developer probably a mid-level developer before it gets to the Senior developer or Lead Developer.

Read my Article; — [The Struggles of a Junior Software Developer](https://piusnmuhumuza.medium.com/the-struggles-of-a-junior-software-developer-20856d57150e) to get a feel of the experience a typical Junior Developer goes through.

* **Mid-Level Developer:**

Mostly referred to as _Intermediate Developer_ on some Job descriptions (JDs) put out by hiring companies or recruiter, _a mid-level Developer_ is any developer with 2–3 years under their belt and has developed a substantial level of technical skills in the software engineering industry.

At this level, a developer has worked on some projects and can work unsupervised on a team among other things or under limited supervision which is typically code/tasks review from the Senior Developer who will act as a guide, mentor, and advisor for the most part.

* **Senior Developer:**

This developer is also known as the **Developer Lead** or **Team Lead** and is often referred to as a problem solver, because of their deep, specialized knowledge and exhaustive experience in the software engineering industry, knowledge of programming languages, tech stack, or even a specific product they are working or worked on.

At this level, a Developer has somewhere 5 to 8 years+ of experience and able to handle complex problems, comfortably review other developers’ codes, solve their problems, be a trendsetter when working on projects, and most importantly mentor Junior & Mid-level Developers.

## What is Software Configuration Management?

In Software Engineering, Software Configuration Management(SCM) is a process to systematically manage, organize, and control the changes in the documents, codes, and other entities during the Software Development Life Cycle.

SCM, part of cross-disciplinary field of configuration management is a discipline of applying administrative and technical direction to:

- Support distributed development and parallel work.
- Identify and document product characteristics and versions.
- Control and track changes to software artifacts.
- Maintain integrity and consistency across components.
- Verify compliance with specifications.
- Report and audit change details.

SCM provides the process backbone for coordinating work between teams and delivering high quality software products primarily to increase productivity with minimal mistakes while also accurately determining who made which revision.

## Software Project Management

The Business Of Project Management is about understanding the management of project information, resourcing, costing and budgeting to deliver on-time, on-budget and in-scope project. Project management of software products can be loosely referred to as Software Project management.

## Understanding risk and uncertainty in Software Project management

In the presence of uncertainty, making a decision about actions today that impact outcomes in the future require some mechanism for determining those outcomes in the absence of perfect information and this absence of information creates risk.

### These decisions typically have one or more of the following characteristics:

* **The Stakes** — The stakes are involved in the decision, such as costs, schedule, delivered capabilities and those impacts on business success or the meeting the objectives.

* **Complexity** — The ramifications of alternatives are difficult to understand the impact of the decision without detailed analysis.

* **Uncertainty** — Uncertainty in key inputs creates uncertainty in the outcome of the decision alternatives and points to risks that may need to be managed.

* **Multiple Attributes** — Larger numbers of attributes cause a larger need for formal analysis.

* **Diversity of Stakeholders** — Attention is warranted to clarify objectives and formulate performance measures when the set of stakeholders reflects a diversity of values, preferences, and perspectives.

### Event Risks and Non-Event Risks

If you limit your risk identification to event risks only, you will not proactively manage all risks that could affect the success of your project – and you will end up taking risks without knowing it. When most people talk about uncertainty and risk in projects, they are thinking only about uncertain future events that could have a negative (or positive) effect on achievement of their project objectives. However, risk includes much more than threats or opportunities to deliverables, the project schedule or budget.

**Event Risk:** refers to situations where you know WHAT could happen with a certain probability while **Non-Event Risks:** refers to situations where you know there is uncertainty in an area, but you don’t know exactly what it is, what could happen, or to what extent something will occur.

Most projects focus only on risks that are uncertain future events that may or may not occur. Examples of these Event-Risks include:

* We may lose a key resource at a critical time in the project
* A key supplier may go out of business during the project
* The customer may change the requirements after the design is complete
* A subcontractor may propose enhancements to the standard operating processes

There is an increasing recognition that also **Non-Event Risks** need to be identified and managed. The following list and figure shows you an overview of Event Risks and Non-Event Risks with their underlying uncertainty.

Event risk (Stochastic Uncertainty)
Ambiguity risk (Epistemic Uncertainty)
Variability risk (Aleatoric Uncertainty)
Emergent risk (Ontological Uncertainty)

### Reducible and Irreducible Uncertainty

There is pervasive confusion between these two types of uncertainties when discussing the impacts on these uncertainties on project outcomes, including the estimates of cost, schedule, and technical performance.

All project work is driven by underlying processes that create a certain probability of uncertainty. There are two types of uncertainty on all projects, called Reducible (Epistemic) and Irreducible (Aleatory) uncertainty.

#### Reducible Uncertainty

A reducible uncertainty is called an epistemic uncertainty which refers to the deficiencies by a lack of knowledge or information while Irreducible uncertainty refers to a situation in which actors are uncertain about whether well-defined propositions (statements about future consequences which can be measured on a probability scale) are true or not.

**Event Risk** (is the result of “Stochastic Uncertainty): ”Uncertainty exist about possible events in the future, An event risk is something that has not yet happened and it may not happen at all, but if it does happen then it has an impact on one or more objectives. Most risks identified in the project risk register are event risks.

You can define actions to reduce the probability of occurrence or the impact of event risks or you can eliminate the risk completely.

**Ambiguity Risk** (is the result of “Epistemic Uncertainty”): The term epistêmê means knowledge in Greek. There are things that we are uncertain about simply because of the lack of knowledge, and the uncertainty might be reduced by gathering more information.

With ambiguous risks there is uncertainty about what might happen in the future. Areas of the project where imperfect knowledge might affect the project’s ability to achieve its objectives include: elements of the requirements or technical solution, future developments in regulatory frameworks, or inherent systemic complexity in the project.

You can reduce ambiguous risks by defining those areas where there is a deficit of knowledge or understanding, then filling the gap by obtaining expert knowledge or benchmarking against best practices. You can also reduce ambiguity, for example, through incremental development, prototyping, or simulation.

#### Irreducible Uncertainty

Aleatoric uncertainty refers to the data's inherent randomness that cannot be explained away  while Epistemic uncertainty refers to the uncertainty of the model (epistemology is the study of knowledge) and is often due to a lack of training data.

Aleatory uncertainty arises from the random variability related to natural processes on the project - the statistical processes. Work durations, productivity, variance in quality. Epistemic uncertainty arises from the incomplete or imprecise nature of available information - the probabilistic assessment of when an event may occur.

**Variability Risk** (is the result of  “aleatoric uncertainty”): Alea in Aleatory is Latin and means dice. Aleatoric uncertainty comes from an inherent randomness, natural stochasticity, environmental or structural variation across space and time in the properties or behavior of the system under study. Here you know that something will definitely happen, but the uncertainty is in what the result will be. The accumulation of more data or additional information cannot reduce aleatory uncertainty.

Aleatory uncertainties can often be singled out from other uncertainties by their representation as distributed quantities that take on values in an established or known range. The exact values will vary by chance from unit to unit or time to time.

Typical examples of aleatory uncertainty include the outcomes of tossing dice and drawing cards from a shuffled pack. Aleatory uncertainty in projects may include: Unseasonal weather conditions may occur during the construction phase. The exchange rate could be much higher or lower when the material is delivered.
For variability risks, we cannot buy more information nor take specific risk reduction actions to reduce the uncertainty and resulting risk. The objective of identifying and managing variability risks is to be prepared to handle the impacts when risk is realized. The method for handling these impacts is to provide margin for this type of risk, including cost, schedule, and technical margin. Aleatoric uncertainty can be modeled in a Monte Carlo simulation tool. Here the range of variation is reflected in the probability distribution.

**Emergent Risk** (is the result of “Ontological Uncertainty): Uncertainty exist from what we don’t know—from our blind-spots. They arise from limitations in our conceptual frameworks or worldview. These are risks which we are unable to see because they are outside our experience or mindset, so we don’t know that we should be looking for them.
Another popular term for emergent risks is “the unknown unknowns,” which are things that we do not know but where we are unaware of our ignorance. In fact “unknown unknowns” can be divided into two types, one of which is a true emergent risk (“Black Swan”) and the other is not. These are:

The “unknown-but-knowable unknowns.” There are some uncertainties that we currently do not know, but which we could find out about. This is where the risk process can help, through creative risk identification, exploration, and education.
The “unknown-and-unknowable unknowns.” These are much more difficult to deal with, since by definition we can never discover them unless and until they happen. They are genuine emergent risks, which we could not predict with even the best risk process.




## Conclusion

Software Engineering/Development outside in the business environment is a very complex process, mostly because real-world software is much larger, more complex and run on big budgets with a lot of uncertainties, timelines and often unreasonable expectations from the various stakeholders.

> ["Programming isn't about what you know; it's about what you can figure out." – Chris Pine.]( https://x.com/CodeWisdom/status/1728034677531763017?s=20)

It is a lucrative venture and getting proficient or mastering the various software engineering concepts, principles, essential processes and industry standards can give you an edge in the cut-throat competitive technology space.

There are several areas to focus on within **Software Engineering**, such as _Programming Basics, Software design, Software Processes, Software Project management, Software testing, Software Quality Assurance(SQA), Configuration Management, Database Design and Administration, Human-Computer Interaction, UI/UX Concepts, Operating Systems, Computer and Software Architecture, Software Modelling and Analysis, Embedded Systems, ML/AI & GenAI, Computer Networking and Security concepts, Research and Development(R&D)/Research Methodology,  Data Structures and Algorithms(DSA), Technical Writing and Social Responsibility/Legal & Ethics among other disciplines._

These can be different or categorized differently depending on the information source, learning center or mode of research on your part.

Today, software development teams run lean processes to focus on end-user feedback and increased value, as noted in the Lean Startup, by Eric Ries, who advocates for rapid prototyping, end-user feedback and early and rapid product delivery.

## Glossary

* **Computer programs** are a set of instructions/algorithms applied to various types of data that is used as a process of creating the software program with the help of a programming language.
* **Development:** Is the process of developing, being developed, or the result of developing.
* **Engineering:** Mostly involves applying science, conventional methods, and applicable tools to find cost-effective and sustainable/scalable solutions to developing problems. This can be in any industry where engineering is applicable.
* **Project management** is the process of planning and executing a project while balancing the time, cost, and scope constraints. Time, cost, and scope are known as the _triple constraint_.
* **Software** is a set of _computer programs_ that enable a computer system (_hardware_) to perform specific tasks.
* **Software Architecture:** Refers to the fundamental structures or building blocks of a software system. The way software components (subroutines, classes, functions) are arranged and interact or integrate with each other.
* **Software Engineering:** Is a systematic, disciplined & more so quantifiable approach to the development, operation, and maintenance of software or software projects.
* **Software Development:** Is a set of activities _conceiving, specifying, designing, programming, deploying, documenting, and testing (bug fixing)_ involved in the process of creating and maintaining software applications, frameworks, or other software components.
* **[Software Development Life Cycle (SDLC);](https://en.wikipedia.org/wiki/Systems_development_life_cycle)** is the process of developing or engineering software. — “the overall process of developing software from start to finish.”
* **Demand versus supply.**  Demands and supplies are the fundamental behaviors of dynamic market systems, which form the context of economics.
* **Demand** is the required quantities for a product or service. It is also the demand for labor and materials needed to produce those products and services. Demand is a fundamental driving force of market systems and the predominant reason for most economic phenomena. The market response to a demand is called supply.  
* **Supply** is the required quantities for a product or service that producers are willing and able to sell at a given range of prices. This also extends to the labor and materials needed to produce the product and services to meet the demand.
* **Efficiency:** Efficiency of a system is generally defined as the ratio of its output to input. The efficiency can be classified into technical efficiency and economic efficiency.
* **Technical efficiency:** It is the ratio of the output to input of a physical system. The physical system may be a diesel engine, a machine working in a shop floor, a furnace, etc. (Technical efficiency (%) =  Output/ Input × 100)
* **Economic efficiency:** Economic efficiency is the ratio of output to input of a business system. (Economic efficiency (%) = Output/Input  × 100 = Worth/Cost × 100)
* **Investment:** Is an asset or item acquired with the goal of generating income or appreciation. (Interest = Current Value – Original Amount)
* **Loan:** Is money, property, or other material goods given to another party in exchange for future repayment of the loan value or principal amount, along with interest or finance charges. (Interest = Current Total Owed – Original Amount)
* **Rate of Return (ROR):** Interest accumulated per unit time. (ROR = Interest accumulated per unit time / Original Amount)
* **Time Value of Money (TVM):** Is the money available at the present time is worth more than the identical sum in the future due to its potential earning capacity.
* **Present Value (PV):** Is the current value of a future sum of money or stream of cash flows given a specified rate of return.
* **Future Value (FV):** Is the value of a current asset at a future date based on an assumed rate of growth.
* * **Money value throughout time:** The time value of money draws from the idea that rational investors prefer to receive money today rather than the same amount of money in the future because of money’s potential to grow in value over a given period of time. For example, money deposited into a savings account earns a certain interest rate and is therefore said to be compounding in value.
* **Cash Flow:** Is the net amount of cash and cash-equivalents being transferred into and out of a business.
* **Interest:** is defined as the cost of borrowing money as in the case of interest charged on a loan balance.(Money paid for the use of money.) Interest can be calculated in two ways, simple interest or compound interest.
* **Simple interest** is calculated on the principal, or original, amount of a loan. Formula: Simple interest = P x i x n; P = principle, i = interest rate and n = term of the load
**Compound interest** is calculated on the principal amount and also on the accumulated interest of previous periods, and can thus be regarded as “interest on interest.” Formula: Compound interest= [P(1+i)^n]−P & Compound interest = P[(1+i)^n−1]; P = principle, i = interest rate in percentage terms and n = number of compounding periods of year.
* **Interest Rate:** Interest paid per unit time. (Interest Rate = Interest paid per unit time / Original Amount)
Interest rate is one of the most commonly used phrases in fixed-income investment lexicon. The different types of interest rates, including real, nominal, effective and annual, are distinguished by key economic factors, that can help individuals become smarter consumers and shrewder investors.
* **Nominal Interest Rate:** Is the stated interest rate of a bond or loan, which signifies the actual monetary price borrowers pay lenders to use their money.
**Effective Interest Rate:** Investors and borrowers should also be aware of the effective interest rate, which takes the concept of compounding into account. «Compounding is the process in which an asset’s earnings.
* **Opportunity Costs** are those cost resulting from the loss of potential gain from the other alternatives then the one alternative chosen by the decision maker. which is where making decisions in the Presence of Uncertainty comes in because making decision is about Opportunity Costs.
* **Software economics** deals with the application of economic principles to software development by focusing on the ever challenging issue of valuing software and estimating the costs involved in its production.
* **Software Engineering** is a technical discipline or approach that applies **computer science** and **engineering** concepts in the design, development, testing and maintenance of quality reliable, usable, and dependable software. Simply put, it's an engineering-based approach to software development.
* **Economics** is the study of how resources (people, time, facilities, money) are used to produce and distribute commodities and how services are provided in society. Economics is classified into microeconomics  and macroeconomics. — Microeconomics is the study of behaviors of individual agents and markets. Macroeconomics is the study of the broad aspects of the economy, for example employment, export, and prices on a national or global scope.
* **[Engineering Economics](https://en.wikipedia.org/wiki/Engineering_economics)** is a branch of microeconomics dealing with engineering related economic decisions and the application of economic principles and methods to engineering problems and decisions. It helps in evaluating the costs and benefits of different alternatives, such as projects, products, processes, or policies,in to make the best choice for your team, business or organization.
* **Software Engineering economics** is the application of economic techniques to the evaluation of Software design, development and engineering alternatives. It facilitates assessment of the appropriateness of a given software project, estimating its value, and justifying it from an business & engineering standpoint.
* **Economics** is a social science concerned chiefly with description and analysis of the production, distribution, and consumption of goods and services. It's the study of how people make decisions in resource-limited situations.

**Macroeconomics** is the study of how people make decisions in resource-limited situations on a national or global scale. It deals with the effects of decisions that national leaders make on such issues "as tax rates, interest rates, foreign and trade policy.

## Reading Resources

- [Software engineering history](https://ifs.host.cs.st-andrews.ac.uk/Books/SE9/Web/History/)
- [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76)
- [History of software engineering]( https://en.wikipedia.org/wiki/History_of_software_engineering)
- [The History of Software Engineering](https://www.lingq.com/en/learn-english-online/courses/10892/the-history-of-software-engineering-10892/)
- [9 Steps to Software Project Handovers](https://betterprogramming.pub/9-steps-to-software-project-handovers-9325fbb72cfc)
- [𝗦𝗼𝗳𝘁𝘄𝗮𝗿𝗲 𝗘𝗻𝗴𝗶𝗻𝗲𝗲𝗿𝗶𝗻𝗴 𝗮𝘁 𝗚𝗼𝗼𝗴𝗹𝗲](https://abseil.io/resources/swe-book/html/toc.html)
- [The Humble Programmer | Edsger W. Dijkstra | ACM Turing Lecture 1972](https://www.youtube.com/watch?v=0dGXRK8FUVg&ab_channel=RenTristandelaCruz)
- [Has the Software Crisis Passed?]( https://medium.com/@ryancohane/has-the-software-crisis-passed-d45ce975a1e7)
- [The Humble Programmer; Recorded by Eric Normand. Published: August 2, 2021. Updated: August 17, 2021.]( https://lispcast.com/the-humble-programmer/)
- [Software Engineering Techniques](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/resources/The%20NATO%20Software%20Engineering%20Conferences/Software-Engineering-techniques_nato1969.pdf)
- [The Software of Civilization](https://foresight.org/the-software-of-civilization/)
- [A Basic understanding of Software Quality Assurance.](https://medium.com/@piusnmuhumuza/a-basic-understanding-of-software-quality-assurance-307317b82867)
* [Software Quality Assurance: Beyond the Basics.](https://piusnmuhumuza.medium.com/software-quality-assurance-beyond-the-basics-f159780bc55f)
* [Being a good Software Quality Assurance Engineer](https://piusnmuhumuza.medium.com/being-a-good-software-quality-assurance-engineer-9e229eba89d6)
- [Software Engineering: A Business Tech Enthusiast Beginner’s Guide](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76)
- [Test Types and Maintenance Testing](https://testingtraveler.com/2021/02/05/test-types-and-maintenance-testing/)
* [The 4 Levels of Testing in Software Engineering Explained](https://fellow.app/blog/engineering/the-levels-of-testing-in-software-engineering-explained/)
* [The different types of software testing](https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing)
* [Software Engineering Body of Knowledge (SWEBOK)](https://www.computer.org/education/bodies-of-knowledge/software-engineering)
* [ISO (International Organization for Standardization)](https://www.techtarget.com/searchdatacenter/definition/ISO)
* [A Guide to Understanding ISO Standards](https://www.jamasoftware.com/blog/a-guide-to-understanding-iso-standards/)
* [Project Management: An Agile Approach to Projects.](https://piusnmuhumuza.medium.com/project-management-an-agile-approach-to-projects-27e11098ce10)
* [Book Review: Scrum by Jeff Sutherland.](https://piusnmuhumuza.medium.com/book-review-scrum-by-jeff-sutherland-55221a14c232)
* [Agile 101](https://www.agilealliance.org/agile101/)
* [Manifesto for Agile Software Development](https://agilemanifesto.org/)
* [Principles behind the Agile Manifesto](https://agilemanifesto.org/principles.html)
* [The Role of Business Analysis in Project Management]( https://www.linkedin.com/pulse/role-business-analysis-project-management-mark-bruins/)
* [The Importance of a Business Analyst in Project Management](https://www.linkedin.com/pulse/importance-business-analyst-project-management-firdaus-jahan-xiwdf/)
* [Project Managers: How to Leverage Business Analysis for Project Success](https://www.adaptiveus.com/blog/business-analysis-for-project-managers/)
* [Why project managers need business analysis](https://harrybakertraining.com/project-management/why-project-managers-need-business-analysis/#:~:text=Business%20analysis%20competency%20helps%20project,the%20delivery%20of%20business%20value.)
* [Building Secure and Reliable Systems](https://google.github.io/building-secure-and-reliable-systems/raw/toc.html)
* [Google Site Reliability Engineering(SRE) Books](https://sre.google/books/)
* [Google SRE Book Github](https://github.com/euclid1990/google-sre-book)
* [Google SRE Book Read Online](https://landing.google.com/sre/sre-book/toc/index.html)
* [system-design-primer](https://github.com/donnemartin/system-design-primer.git)
* [The Economics of Software Development: Beyond Cost](https://www.linkedin.com/pulse/economics-software-development-beyond-cost-laura-hughes/)
* [Software Cost Estimation](https://www.geeksforgeeks.org/software-cost-estimation/)
* [Cost Estimation Models in Software Engineering](https://www.tutorialspoint.com/cost-estimation-models-in-software-engineering)
* [Software Cost Estimation Models in Software Planning](https://www.geeksforgeeks.org/software-cost-estimation-models-in-software-planning/)
* [Manifesto for Agile Software Development](https://agilemanifesto.org/)
* [History: The Agile Manifesto](https://agilemanifesto.org/history.html)
* [Principles behind the Agile Manifesto](https://agilemanifesto.org/principles.html)
* [Authors: The Agile Manifesto](https://agilemanifesto.org/authors.html)
* [Scrum Guides](https://scrumguides.org/index.html)
* [The Agile Coach]( https://www.atlassian.com/agile)
- [Understanding Functional Requirements in Software Development](https://kvytechnology.com/blog/software/functional-requirements/)
- [The 10 Minute Test Plan By James Whittaker](https://testing.googleblog.com/2011/09/10-minute-test-plan.html)
- [How Much Testing is Enough? By George Pirocanac](https://testing.googleblog.com/2021/06/how-much-testing-is-enough.html)

### Tags

``Software``, ``Software Crisis``, ``The Humble Programmer``, ``Computer Science``, ``Software Quality``, ``Software Developer``, ``Software Engineer``, ``Software Crisis``, ``Software Quality Assurance``, ``Software Testing``,``Software Development Life Cycle``, ``SDLC``, ``NATO Science Committee``, ``The NATO Software Engineering Conferences``, ``SWEBOK``,``Software Project Management``, ``Projects``, ``Software Engineering``, ``Software Economics``, ``Engineering Economics``, ``Software Development``, ``Software Projects``, ``Software Engineering economics``, ``software cost models``, ``Software Product Line Engineering``, ``Product Management``, ``Software Architecture``, ``Computer programming costs``, ``cost models``, ``management decision aids``, ``Software Implementation``, ``software management``, ``Project Estimation``, ``Software Cost Estimation``, ``Software Estimation``