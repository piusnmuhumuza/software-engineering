# Software Engineering | A Learning Guide

This is a Complete Software Engineering Summary Notes Guide i put together with basic [Software Engineering](https://piusnmuhumuza.hashnode.dev/a-business-technology-enthusiasts-guide-to-software-engineering) definitions, concepts, and practices for busy business technologists & thought leaders.

## Table Of Contents

- [Introduction](#introduction)
- [What is Software](#what-is-software)
   -[Characteristics of Software](#characteristics-of-software)
- [What is Software Engineering](#what-is-software-engineering)

## Introduction

Back in the 1950s, when the dependency on computers increased, the software needed to manage them also grew and thus [Software Engineering/Development](https://piusnmuhumuza.hashnode.dev/a-business-technology-enthusiasts-guide-to-software-engineering) became a necessity for businesses and users all over the world.

> [“Our civilization depends critically on software, and we have a dangerously low degree of professionalism in the computer fields.” — Bjarne Stroustrup]( https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/resources/BjarneStroustrup.pdf)

In the last 63 years (since 1960), the amount of software produced and used by modern society increased greatly necessitating a need to set principles, objectives, and standards, when estimating the necessary resources (like cost and human capital) for developing quality software to meet customer requirements and manage their expectations.

Today, it is hard to imagine an area of human activity or business endeavour where software is not used, considering most of the devices used in workplaces, households and the large computer infrastructures operating in governmental organizations or large corporations are powered by software.

This publication tries to break down most of the software-related concepts, practices, and topics that anyone in the business of [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) as well as enthusiasts should know about.

## What is Software

Software is a set of _computer programs_ that enable a computer system (_hardware_) to perform specific tasks. Software runs on **hardware** which are the tangible components, or delivery systems that store and run the written instructions provided by the software to perform the actual work.

High-quality software was and is characterized with being highly dependable, safe, secure, reliability, efficient, usable, accessible, and maintainable. It is not feasible to achieve all these in any one software product but achieving some is possible.

### Characteristics of Software

- Software is developed or engineered and not manufactured.
- Software doesn’t wear out but it does require enhancements or scaling depending on how, where, and for whom it’s being developed.
- Software should be applicable, maintainable, scalable, reliable, efficient, and well documented at the very least to be considered quality when handing it over to the client.
- Software and especially good software is operational, transitional, and maintainable.
- Software can also have some restrictions e.g., legal compliances, industry standards, Cost, talent hiring, and time to market among others that need to be considered.

## What is Software Engineering

Software Engineering is a technical discipline or approach that applies **computer science** and **engineering** concepts in the design, development, testing and maintenance of quality reliable, usable, and dependable software.

The professional practice of Software Engineering requires technical proficiency and a high code of ethics, which all enthusiasts of Software Engineering should embody. The [10 commandments of Egoless programming]( https://medium.com/@piusnmuhumuza/reflecting-on-the-10-commandments-of-egoless-programming-1bc4189e32f) by inspired by the book, [The Psychology of Computer Programming]( https://www.goodreads.com/book/show/1660754.The_Psychology_of_Computer_Programming) , first released in the 1970s, where Jerry Weinberg coined the term “egoless programming” partly speaks to this effect.

> [“When a Princeton neighbour of Albert Einstein’s discovered to her horror that her little girl had been going to Einstein for help with her arithmetic homework, she apologized profusely. Think nothing of it, Einstein replied — I have learned more from her than she has from me.”](https://x.com/JerryWeinberg/status/1022591845430452224?s=20) -Tweet by [Gerald Weinberg](https://x.com/JerryWeinberg)

### A brief History of Software Engineering

The term **‘Software Engineering’** first was used in the late 1950s and early 1960s, where ‘The Concept of Software Engineering was first discussed at the 1968 NATO Science Committee in (Garmisch) Germany.

The NATO Science Committee sponsored two conferences ([The NATO Software Engineering Conferences]( http://homepages.cs.ncl.ac.uk/brian.randell/NATO/)) on _Software Engineering_ in 1968 and 1969, which as generally believed, marked the official start of the profession giving the field its initial boost as the term _'Software Engineering'_ was suggested at these conferences to discuss the ['software crisis'](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/theSoftwareCrisis.md), a name given to the difficulties encountered in developing large, complex systems in the 1960s (through the 1970s -80s).

Around this period, a lot of software projects ran over budget and schedule, some causing property damage while a few led to the loss of life.

### The Software Crisis (1960)

[Software Crisis](https://en.wikipedia.org/wiki/Software_crisis) was a term that came to be used in the early days of computing science referring to the difficulty of developing large, complex systems in the 1960s (through the 1970s -80s) as well as writing useful and efficient computer programs (Software) by Software Engineers and Developers within the required time due to the rapid increase in computer power. During this period, the increasing complexity of the software, and inadequacy of the existing methods, lead to many software problems arising which caused many large-scale software development projects to fail.

This ended up costing more money and taking more time to develop Software than was estimated, with the final product often being inefficient and low quality, if, and when, finished at all.

As computers became larger and more powerful, the task of creating equally large and powerful software (computer programs) also became gigantic, and the field struggled to keep up, leading to the situation referred to today as [_“The Software Crisis”_](https://en.wikipedia.org/wiki/Software_crisis)

In his 1972 [Turing Award](https://en.wikipedia.org/wiki/Turing_Award) lecture, [Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra) made a reference to this same problem.

> “But I called this a minor cause; the major cause is... that the machines have become several orders of magnitude more powerful! To put it quite bluntly: as long as there were no machines, programming was no problem at all; when we had a few weak computers, programming became a mild problem, and now we have gigantic computers, programming had become an equally gigantic problem.” –-**[Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra), [The Humble Programmers (1972)](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/theHumbleProgrammer.md)**

The term ["Software Crisis"]( https://en.wikipedia.org/wiki/Software_crisis) was coined together by attendees at the first [NATO Software Engineering Conference](https://en.wikipedia.org/wiki/NATO_Software_Engineering_Conferences) in 1968 at Garmisch, Germany.

### The Beginning of Software Engineering

In the wake of the [Software crisis](https://en.wikipedia.org/wiki/Software_crisis), [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) emerged as a new engineering discipline concerned with all aspects pertaining to software production that encompassed the theories, concepts, principles, techniques, standards, and tools that could be used for developing high-quality and reliable professional software.

By identifying the many problems of software development It was thus, proposed that the adoption of an engineering approach to developing software which is how [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) was conceptualized.

The term [‘Software Engineering’](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) first was used in the late 1950s and early 1960s, where the concept of software engineering was first suggested at the 1968 NATO Science Committee in (Garmisch) Germany, while discussing the '[Software Crisis](https://en.wikipedia.org/wiki/Software_crisis)'. It is generally believed these conferences marked the official start of the profession as the term ['Software Engineering'](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76).
The NATO Science Committee sponsored two conferences ( [The NATO Software Engineering Conferences]( http://homepages.cs.ncl.ac.uk/brian.randell/NATO/)  ) on [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76) in 1968 and 1969, which gave the field its initial boost.

Software Engineering emphasizes a systematic, disciplined approach to the development of software that typically applies to the construction of large software systems (or products) involving numerous Software Development and engineering teams.

Today, Software Development and engineering teams will typically fall under Front-end, Back-end or full-stack development, as is with Developers, Engineers and sometimes Programmers.

## Front-end Vs Back-end Vs Full-stack Development

Front-ends work on what the user can see while Back-ends build the infrastructure that supports it and Full-stacks are both in one. Both Front-ends & Back-ends are necessary components for high-functioning software or applications.

- **Front-end —** ensures a satisfactory user experience with no issues, errors, or downtime by planning, designing, building, and implementing quality user interface systems for the software or application in question. Front-ends create and optimize systems, resolve UI/UX issues and even play an active role in testing and troubleshooting activities.

- **Back-end —** typically deals with the logical back-end and core computational logic. Back-ends are responsible for the server-side/back-end part of a software or application and usually write the business logic of software, web services, and APIs used by front-end.

- **Full-stack —** usually comes with experience of working both as a Front-end and Back-end. Often referred to as “jack-of-all-trades”, Full-stacks have skills in a wide variety of coding niches, databases, graphic design, and UI/UX that enables them do their job well working both the client and server ends.

### The case of a Software Engineer Vs a Software Developer

While _Developers_ and _Engineers_ apply advanced technical skills to create computer programs, and their roles overlap in many ways depending on the team one is working on, _Software Developers_ and _Software Engineers_ typically handle different steps when creating applications.

**Software Developers** identify customer needs, develop, and customize computer software applications, test, and modify the software as needed to meet those needs, for many industries while **Software Engineers** are considered a type of _Software Developer_, who apply engineering principles, knowledge of programming languages, architecture, and structural design to build systems and software solutions for end users and are typically involved in all stages of the Software development life cycle.

The _Software Developer vs. Software Engineer_ issue often puzzles many technology professionals and aspiring software professionals may confuse the two positions, because the two professional roles share similar responsibilities and sometimes educational backgrounds with titles often being used interchangeably, but they generally differ in their methods and outcomes.

_Software Developers_ and _Software Engineers_ typically handle different steps when creating applications with **Software Developers**, often working directly with clients or as part of a team of developers, engineers, and programmers to create software solutions that meet specific user needs and **Software Engineers** typically working in teams with other developers, project managers, product managers and other professionals considering all components of a project and how potential solutions may affect the project overall.

Also, **Software Engineers** tend to be in more collaborative roles, while **Software Developers** often and may work in a more independent environment.

#### Developer expertise Levels

They are basically 3 levels but, in some places, or companies, you will find 5 or 7 levels depending on the breakdown and classifications of the expertise levels.

As you grow your experience in the Software Engineering industry you will go through several levels based on your expertise.

The 3 common basic levels are;-

- **Junior Developer:**

While starting out, most _Developers_ will be Trainees/Apprentices or referred to as Junior Developer most as commonly known in the software industry. At this level, you probably have 0 to 1.5 years of experience tops and everything you know about Software Engineering is basic at best.

You will work on a team where you either pair, work with or have your code reviewed by another Developer probably a mid-level developer before it gets to the Senior developer or Lead Developer.

Read my Article; — [The Struggles of a Junior Software Developer](https://piusnmuhumuza.medium.com/the-struggles-of-a-junior-software-developer-20856d57150e) to get a feel of the experience a typical Junior Developer goes through.

- **Mid-Level Developer:**

Mostly referred to as _Intermediate Developer_ on some Job descriptions (JDs) put out by hiring companies or recruiter, _a mid-level Developer_ is any developer with 2–3 years under their belt and has developed a substantial level of technical skills in the software engineering industry.

At this level, a developer has worked on some projects and can work unsupervised on a team among other things or under limited supervision which is typically code/tasks review from the Senior Developer who will act as a guide, mentor, and advisor for the most part.

- **Senior Developer:**

This developer is also known as the **Developer Lead** or **Team Lead** and is often referred to as a problem solver, because of their deep, specialized knowledge and exhaustive experience in the software engineering industry, knowledge of programming languages, tech stack, or even a specific product they are working or worked on.

At this level, a Developer has somewhere 5 to 8 years+ of experience and able to handle complex problems, comfortably review other developers’ codes, solve their problems, be a trendsetter when working on projects, and most importantly mentor Junior & Mid-level Developers.

## What is Software Configuration Management?

In Software Engineering, Software Configuration Management(SCM) is a process to systematically manage, organize, and control the changes in the documents, codes, and other entities during the Software Development Life Cycle.

SCM, part of cross-disciplinary field of configuration management is a discipline of applying administrative and technical direction to:

- Support distributed development and parallel work.
- Identify and document product characteristics and versions.
- Control and track changes to software artifacts.
- Maintain integrity and consistency across components.
- Verify compliance with specifications.
- Report and audit change details.

SCM provides the process backbone for coordinating work between teams and delivering high quality software products primarily to increase productivity with minimal mistakes while also accurately determining who made which revision.

## Software Project Management

The Business Of Project Management is about understanding the management of project information, resourcing, costing and budgeting to deliver on-time, on-budget and in-scope project. Project management of software products can be loosely referred to as Software Project management.

Software project management is the planning, managing and tracking of software development projects. While the deliverable might differ from other projects that produce tangible deliverables, the processes are basically the same as the management of any other type of project.

It is a holistic approach to managing software projects with a business engineering mindset which focuses on the management of project information, resourcing, costing and budgeting to deliver on-time, on-budget and in-scope projects in Software Engineering.

In Software projects management the _**Software Development Life Cycle (SDLC)**_ process(_Plan, Design, Implement, Test, Deploy, Maintain_ phases), often overlaps the traditional _**Project Management Life Cycle**_ process(_Initiation, Planning, Execution, Monitoring and Control, Closing_ project life cycle phases) and are managed together for successful software development.

### Understanding risk and uncertainty in Software Project management

In the presence of uncertainty, making a decision about actions today that impact outcomes in the future require some mechanism for determining those outcomes in the absence of perfect information and this absence of information creates risk.

#### These decisions typically have one or more of the following characteristics:

- **The Stakes** — The stakes are involved in the decision, such as costs, schedule, delivered capabilities and those impacts on business success or the meeting the objectives.

- **Complexity** — The ramifications of alternatives are difficult to understand the impact of the decision without detailed analysis.

- **Uncertainty** — Uncertainty in key inputs creates uncertainty in the outcome of the decision alternatives and points to risks that may need to be managed.

- **Multiple Attributes** — Larger numbers of attributes cause a larger need for formal analysis.

- **Diversity of Stakeholders** — Attention is warranted to clarify objectives and formulate performance measures when the set of stakeholders reflects a diversity of values, preferences, and perspectives.

#### Event Risks and Non-Event Risks

If you limit your risk identification to event risks only, you will not proactively manage all risks that could affect the success of your project – and you will end up taking risks without knowing it. When most people talk about uncertainty and risk in projects, they are thinking only about uncertain future events that could have a negative (or positive) effect on achievement of their project objectives. However, risk includes much more than threats or opportunities to deliverables, the project schedule or budget.

**Event Risk:** refers to situations where you know WHAT could happen with a certain probability while **Non-Event Risks:** refers to situations where you know there is uncertainty in an area, but you don’t know exactly what it is, what could happen, or to what extent something will occur.

Most projects focus only on risks that are uncertain future events that may or may not occur. Examples of these Event-Risks include:

- We may lose a key resource at a critical time in the project
- A key supplier may go out of business during the project
- The customer may change the requirements after the design is complete
- A subcontractor may propose enhancements to the standard operating processes

There is an increasing recognition that also **Non-Event Risks** need to be identified and managed. The following list and figure shows you an overview of Event Risks and Non-Event Risks with their underlying uncertainty.

Event risk (Stochastic Uncertainty)
Ambiguity risk (Epistemic Uncertainty)
Variability risk (Aleatoric Uncertainty)
Emergent risk (Ontological Uncertainty)

#### Reducible and Irreducible Uncertainty

There is pervasive confusion between these two types of uncertainties when discussing the impacts on these uncertainties on project outcomes, including the estimates of cost, schedule, and technical performance.

All project work is driven by underlying processes that create a certain probability of uncertainty. There are two types of uncertainty on all projects, called Reducible (Epistemic) and Irreducible (Aleatory) uncertainty.

##### Reducible Uncertainty

A reducible uncertainty is called an epistemic uncertainty which refers to the deficiencies by a lack of knowledge or information while Irreducible uncertainty refers to a situation in which actors are uncertain about whether well-defined propositions (statements about future consequences which can be measured on a probability scale) are true or not.

**Event Risk** (is the result of “Stochastic Uncertainty): ”Uncertainty exist about possible events in the future, An event risk is something that has not yet happened and it may not happen at all, but if it does happen then it has an impact on one or more objectives. Most risks identified in the project risk register are event risks.

You can define actions to reduce the probability of occurrence or the impact of event risks or you can eliminate the risk completely.

**Ambiguity Risk** (is the result of “Epistemic Uncertainty”): The term epistêmê means knowledge in Greek. There are things that we are uncertain about simply because of the lack of knowledge, and the uncertainty might be reduced by gathering more information.

With ambiguous risks there is uncertainty about what might happen in the future. Areas of the project where imperfect knowledge might affect the project’s ability to achieve its objectives include: elements of the requirements or technical solution, future developments in regulatory frameworks, or inherent systemic complexity in the project.

You can reduce ambiguous risks by defining those areas where there is a deficit of knowledge or understanding, then filling the gap by obtaining expert knowledge or benchmarking against best practices. You can also reduce ambiguity, for example, through incremental development, prototyping, or simulation.

##### Irreducible Uncertainty

Aleatoric uncertainty refers to the data's inherent randomness that cannot be explained away  while Epistemic uncertainty refers to the uncertainty of the model (epistemology is the study of knowledge) and is often due to a lack of training data.

Aleatory uncertainty arises from the random variability related to natural processes on the project - the statistical processes. Work durations, productivity, variance in quality. Epistemic uncertainty arises from the incomplete or imprecise nature of available information - the probabilistic assessment of when an event may occur.

**Variability Risk** (is the result of  “aleatoric uncertainty”): Alea in Aleatory is Latin and means dice. Aleatoric uncertainty comes from an inherent randomness, natural stochasticity, environmental or structural variation across space and time in the properties or behavior of the system under study. Here you know that something will definitely happen, but the uncertainty is in what the result will be. The accumulation of more data or additional information cannot reduce aleatory uncertainty.

Aleatory uncertainties can often be singled out from other uncertainties by their representation as distributed quantities that take on values in an established or known range. The exact values will vary by chance from unit to unit or time to time.

**Emergent Risk** (is the result of “Ontological Uncertainty): Uncertainty exist from what we don’t know—from our blind-spots. They arise from limitations in our conceptual frameworks or worldview. These are risks which we are unable to see because they are outside our experience or mindset, so we don’t know that we should be looking for them.
Another popular term for emergent risks is “the unknown unknowns,” which are things that we do not know but where we are unaware of our ignorance. In fact “unknown unknowns” can be divided into two types, one of which is a true emergent risk (“Black Swan”) and the other is not. These are:

The “unknown-but-knowable unknowns.” There are some uncertainties that we currently do not know, but which we could find out about. This is where the risk process can help, through creative risk identification, exploration, and education.
The “unknown-and-unknowable unknowns.” These are much more difficult to deal with, since by definition we can never discover them unless and until they happen. They are genuine emergent risks, which we could not predict with even the best risk process.

## Software Development Process and Tools Overview

1. Idea Conception: The initial phase where the concept for a software project is conceived and outlined.
2. Requirements Gathering: Involves collecting and documenting the functional and non-functional requirements for the software.
3. Design and Planning: Creating the architecture and planning the development process based on the gathered requirements.
4. Software Development: The actual coding and implementation of the software based on the design and plan.
5. Continuous Integration and Testing: Regularly integrating code changes and performing automated testing to ensure software quality.
6. Deployment to Staging: Deploying the software to a staging environment for further testing and validation.
7. User Acceptance Testing (UAT): Allowing end-users to test the software to ensure it meets their expectations and requirements.
8. Deployment to Production: Releasing the software to the live production environment for public use.
9. Monitoring and Incident Response: Continuous monitoring of the production environment, with immediate response to any incidents or issues.
10. Post-Production Iteration and Scaling: Making improvements to the software based on user feedback and scaling the system to handle increased load or demand.

## Agile in Software Project Management

Before the agile Methodology, the most popular methodology for managing projects was Waterfall Methodology — the oldest and most traditional project management methodology that follows a sequential process where each step must be completed before the next can begin.

The key difference between Agile and Waterfall is that Waterfall breaks down software development into isolated phases that flow into each other, while Agile advocates for iterative development cycles which can run concurrently.

### Agile

Agile is the ability to create and deal with uncertainty by responding to constant change, where teams are able to deliver quality products by upholding central values & behaviors of; — _trust, Flexibility, empowerment and collaboration._

Teams choose agile so they can respond to changes in the marketplace or feedback from customers quickly without derailing a year's worth of plans. "Just enough" planning and shipping in small, frequent increments lets your team gather feedback on each change and integrate it into future plans at minimal cost.

> Focus on the 20% that matter for an 80% effect.

One of the most effective ways to utilize Agile is using _**MoSoCoW** Prioritization_ (MoSoCoW Method) which stands for; —

- **Must** ‐ Cannot deliver/go live without this.
- **Should** ‐ Important but not vital
- **Could** ‐ Wanted or desirable but less critical. _“nice to haves”_
- **Won’t** ‐ the team has agreed it will not deliver.

#### Characteristics of Agile

- Agile projects produce and deliver work in short bursts (or sprints) of anything up to a few weeks repeated to refine the working deliverable until it meets the client’s requirements.
- Collaborative relationships are established between stakeholders and the team members delivering the work at the beginning of the project and continuing until the project is concluded or even after.
- Agile projects need documentation, reviews and processes just as traditional projects do to meet requirements, manage costs and schedules, deliver benefits and avoid scope creep
- Unlike traditional waterfall project management, Agile doesn’t need to fully understand the project requirements before work can begin. Instead, emphasis is put on delivering a tangible working product (MVP) in short periods which can then be refined until it meets client needs.
- Project progress is measured in a series of working deliverables. So teams need to focus on that 20% of the User Stories (functional work) that contain 80% of the customer value, do those first, deliver them, and repeat.

#### The Agile Manifesto

The [Agile Manifesto](https://agilemanifesto.org/), originally published in February 2001, is a document,  that identifies [four key values](https://agilemanifesto.org/);—

1. **Individuals and interactions** over processes and tools
2. **Working software** over comprehensive documentation
3. **Customer collaboration** over contract negotiation
4. **Responding to change** over following a plan

and [12 principles](https://agilemanifesto.org/principles.html);—

1. Customer satisfaction by early and continuous delivery of valuable software.
2. Welcome changing requirements, even in late development.
3. Deliver working software frequently (weeks rather than months).
4. Close, daily cooperation between business people and developers.
5. Projects are built around motivated individuals, who should be trusted.
6. Face-to-face conversation is the best form of communication (co-location).
7. Working software is the primary measure of progress.
8. Sustainable development, able to maintain a constant pace.
9. Continuous attention to technical excellence and good design.
10. Simplicity—the art of maximizing the amount of work not done—is essential.
11. Best architectures, requirements, and designs emerge from self-organizing teams.
12. Regularly, the team reflects on how to become more effective, and adjusts accordingly.

which its authors believing they were uncovering better ways of developing software by doing it and helping others do it wanted software developers to be able to use to guide their work.

Formally called the Manifesto for [Agile Software Development](https://en.wikipedia.org/wiki/Agile_software_development), it was produced and published by [17 Software Developers](https://agilemanifesto.org/authors.html);—

1. Kent Beck(Extreme Programming)
2. Mike Beedle ([Scrum](https://en.wikipedia.org/wiki/Scrum_(software_development)))
3. Arie van Bennekum
4. Alistair Cockburn (Crystal)
5. Ward Cunningham (Extreme Programming)
6. Martin Fowler (OOAD and UML)
7. James Grenning
8. Jim Highsmith (Adaptive Software Development)
9. Andrew Hunt (Pragmatic Programmer, Ruby)
10. Ron Jeffries
11. Jon Kern
12. Brian Marick (Ruby, TDD)
13. Robert C. Martin (SOLID)
14. Steve Mellor (OOA)
15. Ken Schwaber ([Scrum](https://en.wikipedia.org/wiki/Scrum_(software_development)))
16. Jeff Sutherland ([Scrum](https://en.wikipedia.org/wiki/Scrum_(software_development)))
17. Dave Thomas (Pragmatic Programmer, Ruby)

during an outing, who met at a resort in Snowbird, Utah to discuss lightweight development methods in 2001, who observed an increasing need for an alternative to documentation-driven and heavyweight software development processes. These 17 software Developers, now the [authors of the Agile Manifesto](https://agilemanifesto.org/authors.html).

### Agile Project Management

Agile Project Management is an iterative approach to managing software development projects by focusing on continuous releases and incorporating customer feedback with every iteration. The Agile approach centres around a step-by-step incremental and iterative process to deliver requirements throughout the project lifecycle to completing projects.

#### Agile Methodologies

An Agile methodology is a project management approach that involves breaking a project into phases while emphasizing continuous collaboration and improvement. Teams follow a cycle of planning, executing, and evaluating depending on the methodology used.
The publication of the Agile Manifesto in 2001 marked the birth of agile as a methodology. Since then, many agile frameworks have emerged such as scrum, kanban, lean, and Extreme Programming (XP). 

Each embodies the core principles of frequent iteration, continuous learning, and high quality in its own way. [Scrum](https://en.wikipedia.org/wiki/Scrum_(software_development)) and XP are favored by software development teams, while kanban is a darling among service-oriented teams like IT or human resources.

the Agile group of methodologies demonstrate a commitment to tight feedback cycles and continuous improvement.

#### Project Management methods that fall under Agile include;-

1. **Scrum**, a popular agile methodology that uses daily stand-ups, backlog grooming, and sprint planning meetings to keep teams aligned and productive.
2. **Lean Methodology**, an iterative process that focuses on eliminating waste is based on the philosophy that “less is more.” This methodology is perfect for projects with limited budgets and tight deadlines they would only focus on features and tasks essential to meeting the customer’s needs, eliminating extras to keep costs down and improve efficiency.
3. **Kanban Methodology**, a great project management tool that helps manage workflow by placing tasks on a Kanban board where workflow and progress can be tracked by all team members. Agile teams use Kanban boards to map user stories and plan backlogs in software development or other agile projects and lean manufacturing to reduce inefficiencies.
Kanban (Japanese for sign) developed by Taiichi Ohno, an industrial engineer at Toyota, is an inventory control system used in Just-In-Time (JIT) manufacturing to track production and order new shipments of parts and materials. It was studied by Toyota which applied it to their lean manufacturing model, known as the Toyota production system.
4. **Dynamic System Development Method(DSDM)**, an Agile project delivery framework created in 1994, that focuses on the entire project lifecycle using an iterative and incremental approach to systems development.
DSDM is one of the earliest agile methodologies that was initially used as a software development method originally sought by Project Managers to provide some discipline and governance to the rapid application development (RAD) method for rapid software development and delivery.

#### Other Popular Project Management Methodologies include;

- **Critical Path Method (CPM)**, a mathematically based planning technique used to identify and optimize the sequencing of tasks necessary for project completion and determine scheduling flexibilities to achieve the desired outcome.

A critical path in project management is the longest sequence of activities that must be finished on time for the entire project to be completed.
It is used to calculate the earliest possible time an entire project can be completed by identifying the longest path of tasks, or “critical path,” that must be achieved to finish the project on time.

- **PRINCE2**, Projects IN Controlled Environments(the second version of its kind) thus the acronym PRINCE2 is a well-structured methodology that provides the themes, principles, and processes to control and deliver successful projects of any size and complexity.

This popular framework is based on the tried and tested experiences of project management practitioners around the world and has a globally recognized certification. It is also used for managing UK government and private sector projects even though it’s been criticized for being inflexible and bureaucratic.

- **Six Sigma**, a set of methodologies and tools used to improve quality and business processes by identifying what is not working in the project, reducing defects/errors, minimizing variation, and increasing efficiency.
Six Sigma which also applies to quality management, was introduced by engineers working at Motorola in the mid-1980s, with the goal of Six Sigma of achieving a level of quality that is nearly perfect, with only 3.4 defects per million opportunities.

- **Extreme Programming (XP)**, is an agile software development framework built upon values, principles, and practices, with short development cycles and multiple releases to improve productivity and allow small to mid-sized teams to produce high-quality software and adapt to evolving and changing requirements.
Although many of the XP practices have been around for a while. XP was Created by Kent Beck while working on the Chrysler Comprehensive Compensation System payroll project, as a project leader. In 1999, after leading the C3 project for three years, he published a book (“Extreme Programming Explained”) explaining the Extreme Programming process.

#### Scrum

An agile team unites under a shared vision, then brings it to life the way they know is best. Each team sets their own standards for quality, usability, and completeness. Their _"definition of done"_ then informs how fast they'll churn the work out. Although it can be scary at first, company leaders find that when they put their trust in an agile team, that team feels a greater sense of ownership and rises to meet (or exceed) management's expectations.

[Scrum](https://en.wikipedia.org/wiki/Scrum_(software_development)), a well-known Agile framework for software project management that.  It is a way to get work done as a team in small pieces at a time, with continuous experimentation and feedback loops along the way to learn and improve as you go thus aligning with the Agile philosophy.

##### The Origin of Scrum

Ken Schwaber & Jeff Sutherland first co-presented a paper, [“The SCRUM Development Process”](), in 1995 at the Object-Oriented Programming, Systems, Languages & Applications (OOPSLA) Conference ’95 in Austin, Texas. This was its first public appearance. After its first full implementation at the Easel Corporation in 1993 by Jeff Sutherland, John Scumniotales, and Jeff McKenna, the paper essentially documented the learning that they gained over the previous few years.

The word scrum was adopted from scrimmage in rugby which is used to restart a play after a foul.

A scrimmage included players from each team locking into a scrum until one side gained possession of a rugby ball to resume play. The object of rugby is to move the ball down and up the field one possession at a time until a try is made and as such scrum envisioned to do the same with projects.

Therefore, the focus changes from trying to win the project(game) in one go and try to win each and every milestone and deliverable in sprints (plays/possessions in rugby).

The Scrum approach allows teams to deliver milestones as small pieces in a specific short period, with a specified number of team members.  Just like rugby, winning the small plays/possessions at a time to gain ground on a rugby pitch eventually wins the game, thus as with scrum, completing each milestone in short sprints eventually leads to a successful project completion.

Scrum focus on feedback and regular communication where;-

- The team meets regularly to discuss how they are doing,
- what problems they are encountering, and how they can improve their process.

This constant feedback loop helps ensure that the project stays on track and that any issues are dealt with quickly.

##### Scrum Values

A project team’s success when using scrum depends on five values — _Courage, Focus, Commitment, Respect, and Openness._

![The Scrum Values!](https://github.com/piusnmuhumuza/businessEngineering/blob/main/resources/scrum-values.png "Scrum Values") *Scrum Values*

##### The Scrum Framework

A scrum team uses a scrum framework as a way to encourage transparency, inspection, and adaptation when bringing a product from an idea to life.

![The Scrum Framework!](https://github.com/piusnmuhumuza/businessEngineering/blob/main/resources/scum-framework.png "Scrum framework") *Scrum Framework -Image source: Scrum.org*

The Framework guides the scrum development team in creating a product, with the help of a dynamic list of the most valuable things to do thus focusing on value and high visibility of progress.

[The Scrum Guide](https://scrumguides.org/scrum-guide.html) (the ever-evolving manual for Scrum; Schwaber & Sutherland, 2020) says that to reflect the “responding to change” value, a software project should be broken into development Sprints that are usually two to four weeks long. Each Sprint has a Sprint Plan. Sprint Plans can be defined shortly before the Sprint; Teams (and their customers) might only know what is happening with the project’s development for a couple weeks at a time.

Scrum Teams fit their own methods into the Scrum framework, which the current version of the Scrum Guide divides into three categories: the team, the events, and the artifacts.

##### Scrum Team

The Scrum Team in Scrum typically has three roles: Product Owner, Scrum Master, and Development Team and each team member has a specific role and responsibility within the Scrum framework.

- **A Product Owner** Who also has a leadership role, represents the voice of the customer and has the authority to make decisions about the product but may contribute as a team member.

  - He/She is accountable for maximizing the value of the product resulting from the work of the Scrum Team.
  - He/She decides whether to release or continue development, constantly re‐prioritizing the Product Backlog, and adjusting long-term targets such as releases.
  - As the final judge of requirements questions while considering stakeholder interests he/she is responsible for product vision and the single person responsible for maximizing the return on investment (ROI) of the development effort.

- **A SCRUM Master** Usually has no management authority over the team but is the keeper of the process, who protects and advocates for the team.

  - “He/She is accountable for establishing Scrum as defined in the Scrum Guide.
  - He/She works with the organization to make Scrum possible by ensuring Scrum is understood and enacted by creating an environment conducive to team self-organization, promoting improved engineering practices, and providing leadership.
  - He/She also shields the team from external interference and distractions and helps resolve impediments.

- **The Scrum Development Team** is a cross‐functional, self‐organizing, self‐managing, intensely collaborative team of five to seven people at “best” who are jointly responsible for the delivery of the product.

  - these are the people in the Scrum Team that are committed to creating any aspect of a usable Increment each Sprint.
  - A Scrum Development team plans one sprint at a time with the Product Owner and has autonomy regarding how to develop the increments.
  - Scrum Development teams are most successful when located in one team room, particularly for the first few Sprints with long‐term or full‐time membership.

By and large, The Scrum Master’s focus is process, the Product Owner’s focus is the product (software), and the Developers’/Development Team's focus is creating a product while following Scrum processes.

##### SCRUM Events

Scrum defines five Scrum events(sometimes called ceremonies)

![The Scrum Events!](https://github.com/piusnmuhumuza/businessEngineering/blob/main/resources/scrum-events-time-boxes.png "Scrum Methodology") *Scrum Events Time-Boxes*

1. **A Sprint** is a short, time-boxed period within which a scrum team works to complete a set amount of tasks.fixed-length development periods of “one month or less . . . A new Sprint starts immediately after the conclusion of the previous Sprint.” 

2. **Sprint Planning** initiates the sprint by laying out the work to be performed for the sprint. This resulting plan is created by the collaborative work of the entire Scrum team.“initiates the Sprint by laying out the work to be performed.” 

3. **Daily Scrum** is a 15-minute or less everyday activity of the sprint to inspect progress toward a sprint goal and adapt the Sprint Backlog as necessary, adjusting the upcoming planned work. “a 15-minute event for the Developers of the Scrum Team . . . focuses on progress toward the Sprint Goal and produces an actionable plan for the next day of work.” 

4. **Sprint Review** focus on inspecting the outcome of the sprint and determining future adaptations where the Scrum team presents results to key stakeholders and adapts the product backlog as needed based on feedback or the product owner can opt to release any of the completed functionality. “to inspect the outcome of the Sprint and determine future adaptations. The Scrum Team presents the results of their work to key stakeholders . . .”

5. **Sprint Retrospectives** help Scrum teams plan ways to increase quality and effectiveness by focusing on the process. The scrum team discusses what went well, and areas for improvement as well as making tangible plans for how to improve their processes, tools and relationships. “to plan ways to increase quality and effectiveness . . . Scrum Team inspects how the last Sprint went . . .” 

Going through the motions and having each of the events on the calendar is not enough. To get the most out of Scrum, every Scrum Team needs to understand the purpose behind each event and how each member’s role fits.

![The Scrum Methodology!](https://github.com/piusnmuhumuza/businessEngineering/blob/main/resources/the-scrum-methodology.jpg "Scrum Methodology") *Scrum Methodology*

In a nutshell, A Sprint is a development period that occurs in a series of Sprints, which are each laid out during Sprint Planning. Each day, the Developers have a 15-minute meeting about planning the next workday. Sprints end with a Sprint Review (team and stakeholders) and a Sprint Retrospective (team only).

##### The Artifacts

There are three Scrum artifacts:

- **Product Backlog:** “an emergent, ordered list of what is needed to improve the product.” The Product Backlog contains a rough list of tasks the Scrum Team is planning to do some time, but the tasks haven’t yet been scheduled and may not be defined in detail.

- **Sprint Backlog:** “composed of the Sprint Goal (why), the set of Product Backlog items selected for the Sprint (what), as well as an actionable plan for delivering the Increment (how).” The Sprint Backlog contains tasks the team has decided to work on and has added details about completing the tasks.

- **Increment:** “a concrete stepping stone toward the Product Goal.” An Increment is an achievement toward creating the product (e.g., finishing a feature implementation).

The Scrum Guide (Schwaber & Sutherland, 2020) describes the Scrum framework elements in more detail and defines some of the terms that were unexplained here (e.g., Sprint Goal).
There are several notable Agile methods that can be used within Scrum (or other frameworks, or other software process models).

A few of them:

- **Scrum board:** A way to organize and visualize tasks or work as cards on a board. The board has columns for different categories, and each card is placed within a column. A Scrum board could be a physical bulletin board with sticky notes or index cards. It is also a common feature of task management software.

- **Spike:** A quick and to-the-point investigation for gathering information to help the team answer a question or choose a development path.

- **User story:** A short description of a software feature from the perspective of fulfilling a user need (e.g., using this format: As a ``Software Tester`` I can ``test a software product, end-to-end``, so that ``a quality software product is delivered``). Tasks, priorities, time/cost estimates, and acceptance criteria may be associated with a user story.

### Benefits Of Agile in Software Project Management

- Businesses/clients that use Agile in project management have increased flexibility, transparency, efficiencies, speed up delivery, improved quality, have happy stakeholders and also decrease the risk of missed objectives.
- Increased flexibility and adaptability to change reducing waste and thus faster turnaround times.
- Builds accountability which facilitates faster detection of issues and defects.
- Optimal project control which increases focus on specific customer needs.
- Encourages diversity of ideas which increases improves collaboration and the frequency of feedback.

### Key Activities in Software Engineering when managing Software Projects

Good software is characterized by functional and non-functional requirements among other client needs often specified from which an analysis/planning is made to ascertain a scope. It will also undergo a life-cycle(software process), that involves engineering phases, consisting of concept creation, requirements specification, design, implementation, integration, testing, and deployment.

The Software Development Life Cycle (SDLC) is the process for planning, creating, testing, deploying and post improvement (where required) of a software product. — It consists of stages (Analysis/ Planning, Design, Development/Implementation, Testing, Deployment, and then maintenance.) which are sometimes unchangeable at certain levels depending on the industry, client requirements and team. 

As software evolves, it will undergo monitoring, maintenance and continuous improvement cycles and each software development lifecycle model provides specific guidance to the sequencing and repetition of life cycle activities to deliver high-quality software systems.

Project management in a software engineering environment is unique because of the technical aspects of a software project. While software engineers are generally accountable for the technical aspects of a project, the project manager is accountable for organizational aspects. Sometimes a project manager can be the Software Developer on a project.

The success of an SDLC depends on the people, process, and product and software project management is the glue that holds these aspects together.

#### Software Requirements Gathering and Analysis

During requirements gathering/elicitation, Software Engineer/Developer or Business Analysts interact and collaborate with the various stakeholders, including customers and users, to gather information, assemble the insight, identify, translate, analyze and validate the project's needs about the current state of a software system and desired future state of the software system to be developed. 
Getting familiar with the data, information types, requirements collection techniques, application types, client engineering techniques can go a long way to help your business case. 

### Software Design and Modelling

After requirements and analysis, a Software Engineer/Developer must transform the analysis model into a design model that can be implemented in a specific hardware and software environment.

Good Software design is fundamental to creating successful software which starts with gathering requirements followed by precisely articulating complex ideas using industry-standard design visual language tools such as Unified Modeling Language (UML) which enables you specify, construct, and document the artifacts of the software systems among other activities.

### Software Implementation

Implementation, is the process of converting the specified requirements into an actual software product. This can be programming, coding source code and execution. Software implementation also involves customer engineering to ensure software is working as expected of the client/end user during implementation and deployment.

In most business settings, steps like implementing, testing (User acceptance testing) and deployment can happen concurrently or inter-changeably depending on client requirements or team.

### Software Testing

In the software business, a software product is tested thoroughly like before being shipped to the client. During Software Testing, you validate if the finished product meets set software, requirements, industry standards and passes user acceptance to make sure everything comes together correctly to deliver a software system that performs as expected, functionally and non-functionally.
At a granular level, the purpose of software testing is to identify errors, gaps, or missing requirements and check whether the said software product is defect-free and matches the expected client requirements.

As an Engineer, Developer, Product Manager or Project Manager, it’s important to know the levels of software testing and why going through each level is so crucial for software Quality Assurance and a software project’s success.
There are so many ways of approaching software testing based on the project type, the Software product the client expectations, the budget or the Engineering Team available during the software Life cycle.
But Software Testing in most cases will typically falls under 3 categories; -

- **Functional Testing:** A type of software testing that validates the software against a list of requirements or specifications. These tests aim to assess each application function and mainly involve black box testing. Functional testing analyses details like user interface, database, security, application programming interfaces (APIs), and client/server communication. Functional Testing will usually have _Unit testing, Integration testing, System testing, Interface testing, Regression testing, Beta/acceptance testing_

- **Non-Functional Testing:** Sometimes called performance testing, this method focuses on testing an application for its non-functional elements and requirements. Non-functional elements encompass things like performance, reliability, and usability. An example of a test would be checking how many users can be logged into a tool simultaneously without the tool lagging or glitching. Test carried out here often include _Performance testing, Load testing, Stress testing, Volume testing, Security testing, Compatibility testing, Install testing, Recovery testing, Reliability testing, Usability testing, Compliance testing_.

- **Maintenance Testing:** A method of software testing that aims to uncover software errors or bugs within a program after changes have been made. It retests the program to ensure that after the changes are complete, the changes don’t negatively impact the features within the code or conflict with necessary requirements. Test carried out in Maintenance Testing include Regression testing, confirmation testing.

#### Common Levels of Testing

The different levels of software testing explore the four software testing levels that take place during the development lifecycle with each level conducted thoroughly, checking for something different—nothing should be rushed or skipped.
These are; —

##### Unit Testing

This is usually done at the code level, testing individual parts or components (units) of a software to analyse their functionality and ensure each piece of the software functions correctly on its own and works as intended.

##### Integration Testing

Is the process of testing how different units or components work together when integrated into a larger system to check if the combined units cooperate as expected and don't cause issues when connected. It enables software testers to test units of software when integrated into a whole system to identify any bugs or issues arising from integrations between modules. It is possible to automate integration testing.

##### System Testing

This is the process of testing the entire system (an integrated environment comprising the whole application), where all components are assessed against specific business requirements to verify that it meets the specified requirements, and ensure the complete software system functions correctly and satisfies user needs. Automation tools can be used for System Testing.

##### Acceptance Testing

This is where a team checks if the software meets the requirements and specifications set by the end-users or clients to confirm that the software is ready for release and satisfies the user's expectations and needs. Acceptance testing involves testing the system’s Functional and Non-functional aspects, such as performance, security, usability, accessibility, compatibility, and reliability. Depending on the system’s complexity, it can be done manually or through automation tools.

#### Who does software testing?

- Software Tester
- Software Developer/Engineer.
- Software Quality Assurance Engineers can also test.
- Project Lead/Manager
- End User/Client.

#### Why is Software Testing Needed?

Software testing plays a crucial role in delivering reliable and high-quality software as well as mitigating risks, enhances user satisfaction, and ensuring a smooth user experience. It's essential to have robust testing processes to succeed in order to;-

- Identifying Bugs and Defects
- Ensuring Quality
- Meeting Requirements
- Enhancing Reliability
- Preventing Future Issues and many more.

### Software Project Handover

Software Project handover is the transfer of roles and responsibilities for a software project from one company, team, or person to another.

It is a complex process that includes user acceptance testing, deployment, acceptance criteria, post hand-over maintenance, project to mention but a few depending on the client or the team handling the software project.

Even though project handover is an important part of the software product lifecycle, it can be costly or take unpredictable turns unless appropriate precautionary steps are taken.

Typically, all stakeholders of the software project are present if possible for the hand over where final sign off take place and the Software product is handed of signaling the end of the project and making way for any post-project activities like support, maintenance and continuous improvement



## Conclusion

Software Engineering/Development outside in the business environment is a very complex process, mostly because real-world software is much larger, more complex and run on big budgets with a lot of uncertainties, timelines and often unreasonable expectations from the various stakeholders.

> ["Programming isn't about what you know; it's about what you can figure out." – Chris Pine.]( https://x.com/CodeWisdom/status/1728034677531763017?s=20)

It is a lucrative venture and getting proficient or mastering the various software engineering concepts, principles, essential processes and industry standards can give you an edge in the cut-throat competitive technology space.

There are several areas to focus on within **Software Engineering**, such as _Programming Basics, Software design, Software Processes, Software Project management, Software testing, Software Quality Assurance(SQA), Configuration Management, Database Design and Administration, Human-Computer Interaction, UI/UX Concepts, Operating Systems, Computer and Software Architecture, Software Modelling and Analysis, Embedded Systems, ML/AI & GenAI, Computer Networking and Security concepts, Research and Development(R&D)/Research Methodology,  Data Structures and Algorithms(DSA), Technical Writing and Social Responsibility/Legal & Ethics among other disciplines._

These can be different or categorized differently depending on the information source, learning center or mode of research on your part.

Today, software development teams run lean processes to focus on end-user feedback and increased value, as noted in the Lean Startup, by Eric Ries, who advocates for rapid prototyping, end-user feedback and early and rapid product delivery.

## Glossary

* **Computer programs** are a set of instructions/algorithms applied to various types of data that is used as a process of creating the software program with the help of a programming language.
* **Development:** Is the process of developing, being developed, or the result of developing.
* **Engineering:** Mostly involves applying science, conventional methods, and applicable tools to find cost-effective and sustainable/scalable solutions to developing problems. This can be in any industry where engineering is applicable.
* **Project management** is the process of planning and executing a project while balancing the time, cost, and scope constraints. Time, cost, and scope are known as the _triple constraint_.
* **Software** is a set of _computer programs_ that enable a computer system (_hardware_) to perform specific tasks.
* **Software Architecture:** Refers to the fundamental structures or building blocks of a software system. The way software components (subroutines, classes, functions) are arranged and interact or integrate with each other.
* **Software Engineering:** Is a systematic, disciplined & more so quantifiable approach to the development, operation, and maintenance of software or software projects.
* **Software Development:** Is a set of activities _conceiving, specifying, designing, programming, deploying, documenting, and testing (bug fixing)_ involved in the process of creating and maintaining software applications, frameworks, or other software components.
* **[Software Development Life Cycle (SDLC);](https://en.wikipedia.org/wiki/Systems_development_life_cycle)** is the process of developing or engineering software. — “the overall process of developing software from start to finish.”
* **Demand versus supply.**  Demands and supplies are the fundamental behaviors of dynamic market systems, which form the context of economics.
* **Demand** is the required quantities for a product or service. It is also the demand for labor and materials needed to produce those products and services. Demand is a fundamental driving force of market systems and the predominant reason for most economic phenomena. The market response to a demand is called supply.  
* **Supply** is the required quantities for a product or service that producers are willing and able to sell at a given range of prices. This also extends to the labor and materials needed to produce the product and services to meet the demand.
* **Efficiency:** Efficiency of a system is generally defined as the ratio of its output to input. The efficiency can be classified into technical efficiency and economic efficiency.
* **Technical efficiency:** It is the ratio of the output to input of a physical system. The physical system may be a diesel engine, a machine working in a shop floor, a furnace, etc. (Technical efficiency (%) =  Output/ Input × 100)
* **Economic efficiency:** Economic efficiency is the ratio of output to input of a business system. (Economic efficiency (%) = Output/Input  × 100 = Worth/Cost × 100)
* **Investment:** Is an asset or item acquired with the goal of generating income or appreciation. (Interest = Current Value – Original Amount)
* **Loan:** Is money, property, or other material goods given to another party in exchange for future repayment of the loan value or principal amount, along with interest or finance charges. (Interest = Current Total Owed – Original Amount)
* **Rate of Return (ROR):** Interest accumulated per unit time. (ROR = Interest accumulated per unit time / Original Amount)
* **Time Value of Money (TVM):** Is the money available at the present time is worth more than the identical sum in the future due to its potential earning capacity.
* **Present Value (PV):** Is the current value of a future sum of money or stream of cash flows given a specified rate of return.
* **Future Value (FV):** Is the value of a current asset at a future date based on an assumed rate of growth.
* * **Money value throughout time:** The time value of money draws from the idea that rational investors prefer to receive money today rather than the same amount of money in the future because of money’s potential to grow in value over a given period of time. For example, money deposited into a savings account earns a certain interest rate and is therefore said to be compounding in value.
* **Cash Flow:** Is the net amount of cash and cash-equivalents being transferred into and out of a business.
* **Interest:** is defined as the cost of borrowing money as in the case of interest charged on a loan balance.(Money paid for the use of money.) Interest can be calculated in two ways, simple interest or compound interest.
* **Simple interest** is calculated on the principal, or original, amount of a loan. Formula: Simple interest = P x i x n; P = principle, i = interest rate and n = term of the load
**Compound interest** is calculated on the principal amount and also on the accumulated interest of previous periods, and can thus be regarded as “interest on interest.” Formula: Compound interest= [P(1+i)^n]−P & Compound interest = P[(1+i)^n−1]; P = principle, i = interest rate in percentage terms and n = number of compounding periods of year.
* **Interest Rate:** Interest paid per unit time. (Interest Rate = Interest paid per unit time / Original Amount)
Interest rate is one of the most commonly used phrases in fixed-income investment lexicon. The different types of interest rates, including real, nominal, effective and annual, are distinguished by key economic factors, that can help individuals become smarter consumers and shrewder investors.
* **Nominal Interest Rate:** Is the stated interest rate of a bond or loan, which signifies the actual monetary price borrowers pay lenders to use their money.
**Effective Interest Rate:** Investors and borrowers should also be aware of the effective interest rate, which takes the concept of compounding into account. «Compounding is the process in which an asset’s earnings.
* **Opportunity Costs** are those cost resulting from the loss of potential gain from the other alternatives then the one alternative chosen by the decision maker. which is where making decisions in the Presence of Uncertainty comes in because making decision is about Opportunity Costs.
* **Software economics** deals with the application of economic principles to software development by focusing on the ever challenging issue of valuing software and estimating the costs involved in its production.
* **Software Engineering** is a technical discipline or approach that applies **computer science** and **engineering** concepts in the design, development, testing and maintenance of quality reliable, usable, and dependable software. Simply put, it's an engineering-based approach to software development.
* **Economics** is the study of how resources (people, time, facilities, money) are used to produce and distribute commodities and how services are provided in society. Economics is classified into microeconomics  and macroeconomics. — Microeconomics is the study of behaviors of individual agents and markets. Macroeconomics is the study of the broad aspects of the economy, for example employment, export, and prices on a national or global scope.
* **[Engineering Economics](https://en.wikipedia.org/wiki/Engineering_economics)** is a branch of microeconomics dealing with engineering related economic decisions and the application of economic principles and methods to engineering problems and decisions. It helps in evaluating the costs and benefits of different alternatives, such as projects, products, processes, or policies,in to make the best choice for your team, business or organization.
* **Software Engineering economics** is the application of economic techniques to the evaluation of Software design, development and engineering alternatives. It facilitates assessment of the appropriateness of a given software project, estimating its value, and justifying it from an business & engineering standpoint.
* **Economics** is a social science concerned chiefly with description and analysis of the production, distribution, and consumption of goods and services. It's the study of how people make decisions in resource-limited situations.

**Macroeconomics** is the study of how people make decisions in resource-limited situations on a national or global scale. It deals with the effects of decisions that national leaders make on such issues "as tax rates, interest rates, foreign and trade policy.

## Reading Resources

- [Software engineering history](https://ifs.host.cs.st-andrews.ac.uk/Books/SE9/Web/History/)
- [Software Engineering](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76)
- [History of software engineering]( https://en.wikipedia.org/wiki/History_of_software_engineering)
- [The History of Software Engineering](https://www.lingq.com/en/learn-english-online/courses/10892/the-history-of-software-engineering-10892/)
- [9 Steps to Software Project Handovers](https://betterprogramming.pub/9-steps-to-software-project-handovers-9325fbb72cfc)
- [𝗦𝗼𝗳𝘁𝘄𝗮𝗿𝗲 𝗘𝗻𝗴𝗶𝗻𝗲𝗲𝗿𝗶𝗻𝗴 𝗮𝘁 𝗚𝗼𝗼𝗴𝗹𝗲](https://abseil.io/resources/swe-book/html/toc.html)
- [The Humble Programmer | Edsger W. Dijkstra | ACM Turing Lecture 1972](https://www.youtube.com/watch?v=0dGXRK8FUVg&ab_channel=RenTristandelaCruz)
- [Has the Software Crisis Passed?]( https://medium.com/@ryancohane/has-the-software-crisis-passed-d45ce975a1e7)
- [The Humble Programmer; Recorded by Eric Normand. Published: August 2, 2021. Updated: August 17, 2021.]( https://lispcast.com/the-humble-programmer/)
- [Software Engineering Techniques](https://github.com/piusnmuhumuza/bootcamp/blob/master/Software%20Engineering/resources/The%20NATO%20Software%20Engineering%20Conferences/Software-Engineering-techniques_nato1969.pdf)
- [The Software of Civilization](https://foresight.org/the-software-of-civilization/)
- [A Basic understanding of Software Quality Assurance.](https://medium.com/@piusnmuhumuza/a-basic-understanding-of-software-quality-assurance-307317b82867)
* [Software Quality Assurance: Beyond the Basics.](https://piusnmuhumuza.medium.com/software-quality-assurance-beyond-the-basics-f159780bc55f)
* [Being a good Software Quality Assurance Engineer](https://piusnmuhumuza.medium.com/being-a-good-software-quality-assurance-engineer-9e229eba89d6)
- [Software Engineering: A Business Tech Enthusiast Beginner’s Guide](https://piusnmuhumuza.medium.com/software-engineering-a-business-tech-enthusiast-beginners-guide-1961aa73d76)
- [Test Types and Maintenance Testing](https://testingtraveler.com/2021/02/05/test-types-and-maintenance-testing/)
* [The 4 Levels of Testing in Software Engineering Explained](https://fellow.app/blog/engineering/the-levels-of-testing-in-software-engineering-explained/)
* [The different types of software testing](https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing)
* [Software Engineering Body of Knowledge (SWEBOK)](https://www.computer.org/education/bodies-of-knowledge/software-engineering)
* [ISO (International Organization for Standardization)](https://www.techtarget.com/searchdatacenter/definition/ISO)
* [A Guide to Understanding ISO Standards](https://www.jamasoftware.com/blog/a-guide-to-understanding-iso-standards/)
* [Project Management: An Agile Approach to Projects.](https://piusnmuhumuza.medium.com/project-management-an-agile-approach-to-projects-27e11098ce10)
* [Book Review: Scrum by Jeff Sutherland.](https://piusnmuhumuza.medium.com/book-review-scrum-by-jeff-sutherland-55221a14c232)
* [Agile 101](https://www.agilealliance.org/agile101/)
* [Manifesto for Agile Software Development](https://agilemanifesto.org/)
* [Principles behind the Agile Manifesto](https://agilemanifesto.org/principles.html)
* [The Role of Business Analysis in Project Management]( https://www.linkedin.com/pulse/role-business-analysis-project-management-mark-bruins/)
* [The Importance of a Business Analyst in Project Management](https://www.linkedin.com/pulse/importance-business-analyst-project-management-firdaus-jahan-xiwdf/)
* [Project Managers: How to Leverage Business Analysis for Project Success](https://www.adaptiveus.com/blog/business-analysis-for-project-managers/)
* [Why project managers need business analysis](https://harrybakertraining.com/project-management/why-project-managers-need-business-analysis/#:~:text=Business%20analysis%20competency%20helps%20project,the%20delivery%20of%20business%20value.)
* [Building Secure and Reliable Systems](https://google.github.io/building-secure-and-reliable-systems/raw/toc.html)
* [Google Site Reliability Engineering(SRE) Books](https://sre.google/books/)
* [Google SRE Book Github](https://github.com/euclid1990/google-sre-book)
* [Google SRE Book Read Online](https://landing.google.com/sre/sre-book/toc/index.html)
* [system-design-primer](https://github.com/donnemartin/system-design-primer.git)
* [The Economics of Software Development: Beyond Cost](https://www.linkedin.com/pulse/economics-software-development-beyond-cost-laura-hughes/)
* [Software Cost Estimation](https://www.geeksforgeeks.org/software-cost-estimation/)
* [Cost Estimation Models in Software Engineering](https://www.tutorialspoint.com/cost-estimation-models-in-software-engineering)
* [Software Cost Estimation Models in Software Planning](https://www.geeksforgeeks.org/software-cost-estimation-models-in-software-planning/)
* [Manifesto for Agile Software Development](https://agilemanifesto.org/)
* [History: The Agile Manifesto](https://agilemanifesto.org/history.html)
* [Principles behind the Agile Manifesto](https://agilemanifesto.org/principles.html)
* [Authors: The Agile Manifesto](https://agilemanifesto.org/authors.html)
* [Scrum Guides](https://scrumguides.org/index.html)
* [The Agile Coach]( https://www.atlassian.com/agile)
- [Understanding Functional Requirements in Software Development](https://kvytechnology.com/blog/software/functional-requirements/)
- [The 10 Minute Test Plan By James Whittaker](https://testing.googleblog.com/2011/09/10-minute-test-plan.html)
- [How Much Testing is Enough? By George Pirocanac](https://testing.googleblog.com/2021/06/how-much-testing-is-enough.html)

### Tags

``Software``, ``Software Crisis``, ``The Humble Programmer``, ``Computer Science``, ``Software Quality``, ``Software Developer``, ``Software Engineer``, ``Software Crisis``, ``Software Quality Assurance``, ``Software Testing``,``Software Development Life Cycle``, ``SDLC``, ``NATO Science Committee``, ``The NATO Software Engineering Conferences``, ``SWEBOK``,``Software Project Management``, ``Projects``, ``Software Engineering``, ``Software Economics``, ``Engineering Economics``, ``Software Development``, ``Software Projects``, ``Software Engineering economics``, ``software cost models``, ``Software Product Line Engineering``, ``Product Management``, ``Software Architecture``, ``Computer programming costs``, ``cost models``, ``management decision aids``, ``Software Implementation``, ``software management``, ``Project Estimation``, ``Software Cost Estimation``, ``Software Estimation``